This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitattributes
backend/.env
backend/alembic.ini
backend/alembic/env.py
backend/alembic/README
backend/alembic/script.py.mako
backend/application/cache.py
backend/application/config.py
backend/create_tables.py
backend/dependencies/auth.py
backend/main.py
backend/migrations/env.py
backend/migrations/README
backend/migrations/script.py.mako
backend/models.py
backend/routers/api.py
backend/routers/calculations.py
backend/routers/courses.py
backend/routers/export.py
backend/routers/factor.py
backend/routers/factor1.py
backend/routers/groups.py
backend/routers/test.py
backend/routers/users.py
backend/schemas.py
backend/utils.py
frontend/.gitignore
frontend/components.json
frontend/eslint.config.mjs
frontend/next.config.ts
frontend/package.json
frontend/postcss.config.mjs
frontend/public/file.svg
frontend/public/globe.svg
frontend/public/next.svg
frontend/public/vercel.svg
frontend/public/window.svg
frontend/README.md
frontend/src/app/api/axiosClient.ts
frontend/src/app/authRedirect/authlogic.ts
frontend/src/app/authRedirect/page.tsx
frontend/src/app/globals.css
frontend/src/app/instructor/course/[courseID]/[groupID]/GroupStudentClient.tsx
frontend/src/app/instructor/course/[courseID]/[groupID]/page.tsx
frontend/src/app/instructor/course/[courseID]/columns.tsx
frontend/src/app/instructor/course/[courseID]/CoursePageClient.tsx
frontend/src/app/instructor/course/[courseID]/GroupClient.tsx
frontend/src/app/instructor/course/[courseID]/page.tsx
frontend/src/app/instructor/course/[courseID]/studentTable.tsx
frontend/src/app/instructor/course/page.tsx
frontend/src/app/instructor/instructorlogic.ts
frontend/src/app/instructor/layout.tsx
frontend/src/app/instructor/page.tsx
frontend/src/app/layout.tsx
frontend/src/app/page.tsx
frontend/src/app/student/group/grouplogic.ts
frontend/src/app/student/group/page.tsx
frontend/src/app/student/layout.tsx
frontend/src/app/student/page.tsx
frontend/src/app/student/studentlogic.ts
frontend/src/app/student/survey/[groupID]/[courseID]/[courseCode]/page.tsx
frontend/src/app/student/survey/surveyQuestions.ts
frontend/src/app/test/page.tsx
frontend/src/components/app-sidebar.tsx
frontend/src/components/auth-buttons.tsx
frontend/src/components/file-drop.tsx
frontend/src/components/loginbutton.tsx
frontend/src/components/logoutbutton.tsx
frontend/src/components/TableSurvey.tsx
frontend/src/components/ui/AFTable.tsx
frontend/src/components/ui/button.tsx
frontend/src/components/ui/card.tsx
frontend/src/components/ui/Dashboard.tsx
frontend/src/components/ui/ExportCSV.tsx
frontend/src/components/ui/FactorTable.tsx
frontend/src/components/ui/input.tsx
frontend/src/components/ui/separator.tsx
frontend/src/components/ui/sheet.tsx
frontend/src/components/ui/sidebar.tsx
frontend/src/components/ui/skeleton.tsx
frontend/src/components/ui/Survey.tsx
frontend/src/components/ui/table.tsx
frontend/src/components/ui/tooltip.tsx
frontend/src/hooks/use-mobile.ts
frontend/src/lib/api.ts
frontend/src/lib/utils.ts
frontend/src/providers/auth-provider.tsx
frontend/src/providers/user-provider.tsx
frontend/src/providers/user-sync.tsx
frontend/tsconfig.json
LICENSE
README.md
thing.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitattributes">
# Auto detect text files and perform LF normalization
* text=auto
</file>

<file path="backend/alembic/env.py">
from logging.config import fileConfig
from models import Base  # Import your Base
from sqlalchemy import engine_from_config
from sqlalchemy import pool

from alembic import context



# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config

# Interpret the config file for Python logging.
# This line sets up loggers basically.
if config.config_file_name is not None:
    fileConfig(config.config_file_name)

# add your model's MetaData object here
# for 'autogenerate' support
# from myapp import mymodel
# target_metadata = mymodel.Base.metadata
target_metadata = Base.metadata
# other values from the config, defined by the needs of env.py,
# can be acquired:
# my_important_option = config.get_main_option("my_important_option")
# ... etc.


def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online() -> None:
    """Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.

    """
    connectable = engine_from_config(
        config.get_section(config.config_ini_section, {}),
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )

    with connectable.connect() as connection:
        context.configure(
            connection=connection, target_metadata=target_metadata
        )

        with context.begin_transaction():
            context.run_migrations()


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()
</file>

<file path="backend/alembic/README">
Generic single-database configuration.
</file>

<file path="backend/alembic/script.py.mako">
"""${message}

Revision ID: ${up_revision}
Revises: ${down_revision | comma,n}
Create Date: ${create_date}

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
${imports if imports else ""}

# revision identifiers, used by Alembic.
revision: str = ${repr(up_revision)}
down_revision: Union[str, None] = ${repr(down_revision)}
branch_labels: Union[str, Sequence[str], None] = ${repr(branch_labels)}
depends_on: Union[str, Sequence[str], None] = ${repr(depends_on)}


def upgrade() -> None:
    """Upgrade schema."""
    ${upgrades if upgrades else "pass"}


def downgrade() -> None:
    """Downgrade schema."""
    ${downgrades if downgrades else "pass"}
</file>

<file path="backend/application/cache.py">
from fastapi import FastAPI
from datetime import datetime, timedelta
import asyncio
from typing import Optional, Any

class AppCache:
    def __init__(self, max_size: int = 1000):
        self._cache = {}
        self._access_times = {}
        self._max_size = max_size
    
    def get(self, key: str) -> Optional[Any]:
        if key in self._cache:
            value, expiry = self._cache[key]
            if datetime.now() < expiry:
                self._access_times[key] = datetime.now()
                return value
            else:
                self._evict(key)
        return None
    
    def set(self, key: str, value: Any, ttl_seconds: int = 300):
        if len(self._cache) >= self._max_size:
            self._evict_lru()
        
        expiry = datetime.now() + timedelta(seconds=ttl_seconds)
        self._cache[key] = (value, expiry)
        self._access_times[key] = datetime.now()
    
    def _evict(self, key: str):
        self._cache.pop(key, None)
        self._access_times.pop(key, None)
    
    def _evict_lru(self):
        if not self._access_times:
            return
        oldest_key = min(self._access_times.keys(), key=lambda k: self._access_times[k])
        self._evict(oldest_key)

# Global cache instance
cache = AppCache(max_size=5000)  

# EXAMPLE USAGE:
# @app.get("/users/{user_id}")
# async def get_user(user_id: int):
#     cache_key = f"user:{user_id}"
    
#     cached_user = cache.get(cache_key)
#     if cached_user:
#         return cached_user
    
#     # Fetch from database
#     user_data = await get_user_from_db(user_id)
    
#     # Cache for 10 minutes
#     cache.set(cache_key, user_data, ttl_seconds=600)
    
#     return user_data
</file>

<file path="backend/application/config.py">
from functools import lru_cache

from pydantic_settings import BaseSettings


class Settings(BaseSettings):
    auth0_domain: str
    auth0_api_audience: str
    auth0_issuer: str
    auth0_algorithms: str

    class Config:
        env_file = ".env"


@lru_cache()
def get_settings():
    return Settings()
</file>

<file path="backend/dependencies/auth.py">
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from jose import JWTError, jwt
import requests
import os

#set up bearer token authentication scheme, HTTPBearer() looks for tokens in the "Authoriation" header
security = HTTPBearer()

# extract the jwt from the header
async def validate_token(credentials: HTTPAuthorizationCredentials = Depends(security)):
    try:
        token = credentials.credentials #get the raw token string from header
        # get keys
        jwks_url = f"https://{os.getenv('AUTH0_DOMAIN')}/.well-known/jwks.json" #JWKS (JSON Web Key Sets) rae a collection of public cryptographic keys used to verify JSON Web Tokens, Auth0 exposes these keys at this endpoint
        jwks = requests.get(jwks_url).json() # JSON object containing public keys from that endpoint
        
        header = jwt.get_unverified_header(token)
        rsa_key = {}
        for key in jwks["keys"]:
            if key["kid"] == header["kid"]:
                rsa_key = {
                    "kty": key["kty"], # KEY TYPE
                    "kid": key["kid"], # KEY ID
                    "use": key["use"], # Usage
                    "n": key["n"],     # Modulus
                    "e": key["e"]      # Exponent
                }
                
        if not rsa_key:
            raise HTTPException(status_code=401, detail="Invalid token header")
            
        payload = jwt.decode(
            token,
            rsa_key,
            algorithms=["RS256"],
            audience=os.getenv("AUTH0_AUDIENCE"),
            issuer=f"https://{os.getenv('AUTH0_DOMAIN')}/"
        )
        return payload
    except JWTError as e:
        raise HTTPException(status_code=401, detail=str(e))
    

"""
[Client Request]  
       ↓
[Authorization: Bearer <JWT>]  
       ↓
Extract JWT from Header  
       ↓
Fetch JWKS from Auth0  
       ↓
Find Matching Public Key (via kid)  
       ↓
Verify Signature & Validate Claims  
       ↓
If valid → Return Payload  
If invalid → 401 Error

"""
</file>

<file path="backend/migrations/env.py">
from logging.config import fileConfig

from sqlalchemy import engine_from_config
from sqlalchemy import pool

from alembic import context

# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config

# Interpret the config file for Python logging.
# This line sets up loggers basically.
if config.config_file_name is not None:
    fileConfig(config.config_file_name)

# add your model's MetaData object here
# for 'autogenerate' support
# from myapp import mymodel
# target_metadata = mymodel.Base.metadata
target_metadata = None

# other values from the config, defined by the needs of env.py,
# can be acquired:
# my_important_option = config.get_main_option("my_important_option")
# ... etc.


def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online() -> None:
    """Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.

    """
    connectable = engine_from_config(
        config.get_section(config.config_ini_section, {}),
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )

    with connectable.connect() as connection:
        context.configure(
            connection=connection, target_metadata=target_metadata
        )

        with context.begin_transaction():
            context.run_migrations()


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()
</file>

<file path="backend/migrations/README">
Generic single-database configuration.
</file>

<file path="backend/migrations/script.py.mako">
"""${message}

Revision ID: ${up_revision}
Revises: ${down_revision | comma,n}
Create Date: ${create_date}

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
${imports if imports else ""}

# revision identifiers, used by Alembic.
revision: str = ${repr(up_revision)}
down_revision: Union[str, None] = ${repr(down_revision)}
branch_labels: Union[str, Sequence[str], None] = ${repr(branch_labels)}
depends_on: Union[str, Sequence[str], None] = ${repr(depends_on)}


def upgrade() -> None:
    """Upgrade schema."""
    ${upgrades if upgrades else "pass"}


def downgrade() -> None:
    """Downgrade schema."""
    ${downgrades if downgrades else "pass"}
</file>

<file path="backend/routers/export.py">
import pandas as pd
from ..application.cache import cache;
from .courses import get_students_in_course_helper
from models import get_db
from sqlalchemy.orm import Session
from fastapi import APIRouter, Depends, HTTPException, File, UploadFile, Form, Body, Request, Header, Query
from models import SessionLocal, User, Course, Group, Student, StudentGroup, StudentCourse


async def getCSVData(courseID: int, db: Session = Depends(get_db)):
    enrolledin_key: str = f"enrolledin:{courseID}" # Key to access students enrolled in course
    result = {
        "Student Name": [],
        "Course": [],
        "UTORID": [],
        "Group Number": [],
        "AF With": [],
        "AF Without": []
    }
    #Get the group ids, then from that get students in groups then set the data, then convert to csv
    # group_key = f"course:{courseID}"
    # group_ids = cache.get(group_key)
    groups = await getGroups(courseID=courseID, db=db)

    for group in groups:
        students = await getStudents(courseID=courseID, db=db)
        student_names = [student['name'] for student in students]
        student_utorids = [student['utorid'] for student in students]
        group_numbers = [group['groupNumber']] * len(students)
        
        #get students in group


    student_ids = cache.get(enrolledin_key)

    if student_ids == None:
        cache_data = get_students_in_course_helper(courseID=courseID, db=db)
        cache.set(key=enrolledin_key, value=cache_data, ttl_seconds=600)
        student_ids = cache.get(enrolledin_key)
    
    for studentID in student_ids:
        student_key = f"student:{studentID}"
        student_data = cache.get(key=student_key)

        if student_data == None:
            pass
        result["Student Name"].append(student_data["name"])
        result["UTORID"].append(student_data["utorid"])




        
    df = pd.DataFrame(result)
    csvfile = df.to_csv('adjustmentfactors.csv', index=False) 
    return csvfile


async def getGroups(courseID: int, db: Session = Depends(get_db)):
    course = db.query(Course).filter(Course.id == courseID).first()
    groups = db.query(Group).filter(Group.courseCode == course.code).all()
    return groups

async def getStudents(groupID: int, db: Session = Depends(get_db)):
    group = db.query(Group).filter(
        Group.id == groupID,
    ).first()

    if not group:
        raise HTTPException(status_code=404, detail="Group not found in this course")

    # Query StudentGroup directly with the provided groupID
    student_group_relations = db.query(StudentGroup).filter(
        StudentGroup.group_id == groupID  # Fixed filter to use the parameter
    ).all()

    # 3. Fixed list comprehension syntax
    studentIDs = [row.student_id for row in student_group_relations]

    students = db.query(Student).filter(Student.id.in_(studentIDs)).all()
    return students
</file>

<file path="backend/routers/factor.py">
from fastapi import APIRouter, Depends, HTTPException
from fastapi.responses import Response
from models import SessionLocal, User, Course, Group, Student, StudentGroup, StudentCourse, StudentSurvey, StudentAdjustmentFactor
from sqlalchemy.orm import Session
from pydantic import BaseModel
from typing import Optional, List
from models import get_db
from routers.groups import StudentSurveyBase
import pandas as pd


router = APIRouter()

class StudentAdjFactor(BaseModel):
    name: str
    courseCode: str 
    utorid: str
    courseid: int
    groupNumber: int
    factorWithSelf: float
    factorWithoutSelf: float
    

async def get_factors(courseID: int, db: Session = Depends(get_db)):
    factordata = db.query(StudentAdjustmentFactor).filter(
        StudentAdjustmentFactor.courseid == courseID,
    ).all()
    return factordata

@router.get('/fetchFactors')
async def fetch_factors(courseID: int, db: Session = Depends(get_db)):
    factordata = await get_factors(courseID=courseID, db=db)
    return factordata

@router.get('/makeCSV')
async def make_CSV(courseID: int, db: Session = Depends(get_db)):
    factordata = await get_factors(courseID=courseID, db=db)
    data_dicts = [obj.__dict__ for obj in factordata]
    for d in data_dicts:
        d.pop('_sa_instance_state', None)
    df = pd.DataFrame(data_dicts)
    
    csv_data = df.to_csv(index=False)
    return Response(
        content=csv_data,
        media_type="text/csv",
        headers={"Content-Disposition": "attachment; filename=students.csv"}
    )


async def get_denominator(groupID: int, courseID: int, studentID: int, includeSelf: bool, db: Session = Depends(get_db)):
    data = await get_data(groupID=groupID, courseID=courseID, db=db)
    if not includeSelf:
        data = [
            d for d in data 
            if not (d.evaluator_id == studentID and d.evaluatee_id == studentID)
        ]
        
    num_instances = len(data)
    if num_instances == 0:
        print("did not fill out yet")
        return None

    
    total = 0
    for instance in data:
        total = total + instance.answer  # Changed from instance.get("answer")
    denominator = total / num_instances

    return denominator

async def calculateFactor(groupID: int, courseID: int, studentID: int, denominator: int, includeSelf: bool, db: Session = Depends(get_db)):
    if denominator == 0:
        return None
    data = await get_data(groupID=groupID, courseID=courseID, db=db)
    student_instances = [d for d in data if d.evaluatee_id == studentID]  # Changed from d.get("evaluatee_id")
    
    if not includeSelf:
        student_instances = [
            d for d in student_instances 
            if not (d.evaluator_id == studentID and d.evaluatee_id == studentID)
        ]
    
    num_instances = len(student_instances)



    total = 0
    if num_instances == 0:
        return 0
    for instance in student_instances:
        total = total + instance.answer  # Changed from instance.get("answer")
    numerator = total / num_instances
    factor = numerator / denominator
    return factor

async def get_data(groupID: int, courseID: int, db: Session = Depends(get_db)):
    instances = db.query(StudentSurvey).filter(
        StudentSurvey.course_id == courseID,
        StudentSurvey.group_id == groupID
    ).all()
    
    # Don't raise exception for empty results - let caller handle it
    return instances


async def getStudentsInGroup(groupID: int, db: Session):
    group = db.query(Group).filter(
        Group.id == groupID,
    ).first()

    if not group:
        raise HTTPException(status_code=404, detail="Group not found in this course")

    # Query StudentGroup directly with the provided groupID
    student_group_relations = db.query(StudentGroup).filter(
        StudentGroup.group_id == groupID  # Fixed filter to use the parameter
    ).all()

    # 3. Fixed list comprehension syntax
    studentIDs = [row.student_id for row in student_group_relations]

    students = db.query(Student).filter(Student.id.in_(studentIDs)).all()
    return students



async def getGroup(groupID: int, db: Session):
    group: Group = db.query(Group).filter(Group.id == groupID).first()
    return group.groupNumber
    

@router.post("/addmultiple/")
async def addMultiple(groupID: int, courseID: int, courseCode: str, db: Session = Depends(get_db)):
    try:
        print(f"Starting addMultiple with groupID: {groupID}, courseID: {courseID}")
        groupNumber: int = await getGroup(groupID=groupID, db=db)
        # Get students in the group
        students: list[Student] = await getStudentsInGroup(groupID=groupID, db=db)
        print(f"Found {len(students)} students")
        
        if not students:
            raise HTTPException(status_code=404, detail="No students found in this group")
        
        # Check if there are any survey responses at all
        survey_data = await get_data(groupID=groupID, courseID=courseID, db=db)
        if not survey_data:
            raise HTTPException(status_code=400, detail="No survey responses found for this group. Students must complete evaluations first.")
        
        results = []
        skipped_students = []
        
        for student in students:
            print(f"Processing student: {student.name} (ID: {student.student_id})")
            
            try:
                # Calculate denominator without self-evaluation
                denominatorw = await get_denominator(
                    groupID=groupID, 
                    courseID=courseID, 
                    studentID=student.id,
                    includeSelf=True, 
                    db=db
                )
                
                factorw = await calculateFactor(
                    groupID=groupID, 
                    courseID=courseID, 
                    studentID=student.id,
                    denominator=denominatorw,
                    includeSelf=True, 
                    db=db
                )
                
                denominatorwo = await get_denominator(
                    groupID=groupID, 
                    courseID=courseID, 
                    studentID=student.id,
                    includeSelf=False, 
                    db=db
                )
                
                factorwo = await calculateFactor(
                    groupID=groupID, 
                    courseID=courseID, 
                    studentID=student.id,
                    denominator=denominatorwo,
                    includeSelf=False, 
                    db=db
                )
                
                # Check if we got valid factors
                if factorwo is None and factorw is None:
                    print(f"Skipping {student.name} - insufficient evaluation data")
                    skipped_students.append({
                        "student_id": student.student_id,
                        "name": student.name,
                        "reason": "Insufficient evaluation data"
                    })
                    continue
                
                # Create Pydantic model
                data: StudentAdjFactor = StudentAdjFactor(
                    name=student.name,
                    courseCode=courseCode,
                    utorid=student.utorid,
                    groupNumber=groupNumber,
                    courseid=courseID,
                    factorWithoutSelf=factorwo,
                    factorWithSelf=factorw
                )
                
                # Create database instance
                db_instance = StudentAdjustmentFactor(**data.model_dump())
                db.add(db_instance)
                print(f"Added {student.name} to database session")
                
                results.append({
                    "student_id": student.student_id,
                    "name": student.name,
                    "factorWithSelf": factorw,
                    "factorWithoutSelf": factorwo
                })
                
            except Exception as e:
                print(f"Error processing student {student.name}: {str(e)}")
                skipped_students.append({
                    "student_id": student.student_id,
                    "name": student.name,
                    "reason": str(e)
                })
                continue
        
        # Only commit if we have successful results
        if results:
            db.commit()
            print("Successfully committed all changes")
        else:
            db.rollback()
            raise HTTPException(status_code=400, detail="No students could be processed. All students may be missing evaluation data.")
        
        response = {
            "message": f"Successfully processed {len(results)} students",
            "results": results
        }
        
        if skipped_students:
            response["skipped_students"] = skipped_students
            response["message"] += f", skipped {len(skipped_students)} students"
        
        return response
        
    except HTTPException as he:
        print(f"HTTP Exception: {he.detail}")
        db.rollback()
        raise
    except Exception as e:
        print(f"Unexpected error: {str(e)}")
        import traceback
        traceback.print_exc()
        db.rollback()
        raise HTTPException(status_code=500, detail=f"Error processing students: {str(e)}")




@router.post('/addData/')
async def addSingleStudentData(groupID: int, courseID: int, courseCode: str, studentID: int, db: Session = Depends(get_db)):
    try:
        print(f"Processing single student data for studentID: {studentID}")
        
        # Check if there are any survey responses at all
        survey_data = await get_data(groupID=groupID, courseID=courseID, db=db)
        if not survey_data:
            raise HTTPException(status_code=400, detail="No survey responses found for this group. Students must complete evaluations first.")
        
        # Calculate factors
        denominatorw = await get_denominator(
            groupID=groupID, 
            courseID=courseID, 
            studentID=studentID,
            includeSelf=True, 
            db=db
        )
        
        factorw = await calculateFactor(
            groupID=groupID, 
            courseID=courseID, 
            studentID=studentID,
            denominator=denominatorw,
            includeSelf=True, 
            db=db
        )
        
        denominatorwo = await get_denominator(
            groupID=groupID, 
            courseID=courseID, 
            studentID=studentID,
            includeSelf=False, 
            db=db
        )
        
        factorwo = await calculateFactor(
            groupID=groupID, 
            courseID=courseID, 
            studentID=studentID,
            denominator=denominatorwo,
            includeSelf=False, 
            db=db
        )
        
        # Check if we got valid factors
        if factorwo is None or factorw is None:
            raise HTTPException(status_code=400, detail="Insufficient evaluation data for this student. Student may not have been evaluated by peers.")
        
        # Get student info
        student_row: Student = db.query(Student).filter(Student.id == studentID).first()
        if not student_row:
            raise HTTPException(status_code=404, detail="Student not found")
        
        # Create data model
        data: StudentAdjFactor = StudentAdjFactor(
            name=student_row.name,
            courseCode=courseCode,
            utorid=student_row.utorid,
            groupNumber=groupID,
            courseid=courseID,
            factorWithoutSelf=factorwo,
            factorWithSelf=factorw
        )
        
        # Save to database
        db_instance = StudentAdjustmentFactor(**data.model_dump())
        db.add(db_instance)
        db.commit()
        db.refresh(db_instance)
        
        return {
            "message": "Factor added to database successfully",
            "data": {
                "student_id": studentID,
                "name": student_row.name,
                "factorWithSelf": factorw,
                "factorWithoutSelf": factorwo
            }
        }
        
    except HTTPException as he:
        db.rollback()
        raise
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=500, detail=f"Error processing student data: {str(e)}")
</file>

<file path="backend/routers/factor1.py">
from fastapi import APIRouter, Depends, HTTPException
from models import SessionLocal, User, Course, Group, Student, StudentGroup, StudentCourse, StudentSurvey, StudentAdjustmentFactor
from sqlalchemy.orm import Session
from pydantic import BaseModel
from typing import Optional, List
from models import get_db
from routers.groups import StudentSurveyBase


router = APIRouter()

class StudentAdjFactor(BaseModel):
    name: str
    courseCode: str 
    utorid: str
    courseid: int
    groupNumber: int
    factorWithSelf: float
    factorWithoutSelf: float
    


async def get_denominator(groupID: int, courseID: int, studentID: int, includeSelf: bool, db: Session = Depends(get_db)):
    data = await get_data(groupID=groupID, courseID=courseID, db=db)
    if not includeSelf:
        data = [
            d for d in data 
            if not (d.evaluator_id == studentID and d.evaluatee_id == studentID)
        ]
        
    num_instances = len(data)
    if num_instances == 0:
        print("did not fill out yet")
        return None

    
    total = 0
    for instance in data:
        total = total + instance.answer  # Changed from instance.get("answer")
    denominator = total / num_instances

    return denominator

async def calculateFactor(groupID: int, courseID: int, studentID: int, denominator: int, includeSelf: bool, db: Session = Depends(get_db)):
    if denominator == 0:
        return None
    data = await get_data(groupID=groupID, courseID=courseID, db=db)
    student_instances = [d for d in data if d.evaluatee_id == studentID]  # Changed from d.get("evaluatee_id")
    
    if not includeSelf:
        student_instances = [
            d for d in data 
            if not (d.evaluator_id == studentID and d.evaluatee_id == studentID)
        ]
    
    num_instances = len(student_instances)


    if num_instances == 0:
        return None
    total = 0

    for instance in student_instances:
        total = total + instance.answer  # Changed from instance.get("answer")
    numerator = total / num_instances
    factor = numerator / denominator
    return factor

async def get_data(groupID: int, courseID: int, db: Session = Depends(get_db)):
    instances = db.query(StudentSurvey).filter(
        StudentSurvey.course_id == courseID,
        StudentSurvey.group_id == groupID
    ).all()
    
    # Don't raise exception for empty results - let caller handle it
    return instances


async def getStudentsInGroup(groupID: int, db: Session):
    group = db.query(Group).filter(
        Group.id == groupID,
    ).first()

    if not group:
        raise HTTPException(status_code=404, detail="Group not found in this course")

    # Query StudentGroup directly with the provided groupID
    student_group_relations = db.query(StudentGroup).filter(
        StudentGroup.group_id == groupID  # Fixed filter to use the parameter
    ).all()

    # 3. Fixed list comprehension syntax
    studentIDs = [row.student_id for row in student_group_relations]

    students = db.query(Student).filter(Student.id.in_(studentIDs)).all()
    return students

@router.post("/addmultiple/")
async def addMultiple(groupID: int, courseID: int, courseCode: str, db: Session = Depends(get_db)):
    try:
        print(f"Starting addMultiple with groupID: {groupID}, courseID: {courseID}")
        
        # Get students in the group
        students: list[Student] = await getStudentsInGroup(groupID=groupID, db=db)
        print(f"Found {len(students)} students")
        
        if not students:
            raise HTTPException(status_code=404, detail="No students found in this group")
        
        # Check if there are any survey responses at all
        survey_data = await get_data(groupID=groupID, courseID=courseID, db=db)
        if not survey_data:
            raise HTTPException(status_code=400, detail="No survey responses found for this group. Students must complete evaluations first.")
        
        results = []
        skipped_students = []
        
        for student in students:
            print(f"Processing student: {student.name} (ID: {student.student_id})")
            
            try:
                # Calculate denominator without self-evaluation
                denominatorwo = await get_denominator(
                    groupID=groupID, 
                    courseID=courseID, 
                    studentID=student.student_id,
                    includeSelf=False, 
                    db=db
                )
                
                # Calculate factor without self-evaluation
                factorwo = await calculateFactor(
                    groupID=groupID, 
                    courseID=courseID, 
                    studentID=student.student_id,
                    denominator=denominatorwo,
                    includeSelf=False, 
                    db=db
                )
                
                # Calculate denominator with self-evaluation
                denominatorw = await get_denominator(
                    groupID=groupID, 
                    courseID=courseID, 
                    studentID=student.student_id,
                    includeSelf=True, 
                    db=db
                )
                
                # Calculate factor with self-evaluation
                factorw = await calculateFactor(
                    groupID=groupID, 
                    courseID=courseID, 
                    studentID=student.student_id,
                    denominator=denominatorw,
                    includeSelf=True, 
                    db=db
                )
                
                # Check if we got valid factors
                if factorwo is None and factorw is None:
                    print(f"Skipping {student.name} - insufficient evaluation data")
                    skipped_students.append({
                        "student_id": student.student_id,
                        "name": student.name,
                        "reason": "Insufficient evaluation data"
                    })
                    continue
                
                # Create Pydantic model
                data: StudentAdjFactor = StudentAdjFactor(
                    name=student.name,
                    courseCode=courseCode,
                    utorid=student.utorid,
                    groupNumber=groupID,
                    courseid=courseID,
                    factorWithoutSelf=factorwo,
                    factorWithSelf=factorw
                )
                
                # Create database instance
                db_instance = StudentAdjustmentFactor(**data.model_dump())
                db.add(db_instance)
                print(f"Added {student.name} to database session")
                
                results.append({
                    "student_id": student.student_id,
                    "name": student.name,
                    "factorWithSelf": factorw,
                    "factorWithoutSelf": factorwo
                })
                
            except Exception as e:
                print(f"Error processing student {student.name}: {str(e)}")
                skipped_students.append({
                    "student_id": student.student_id,
                    "name": student.name,
                    "reason": str(e)
                })
                continue
        
        # Only commit if we have successful results
        if results:
            db.commit()
            print("Successfully committed all changes")
        else:
            db.rollback()
            raise HTTPException(status_code=400, detail="No students could be processed. All students may be missing evaluation data.")
        
        response = {
            "message": f"Successfully processed {len(results)} students",
            "results": results
        }
        
        if skipped_students:
            response["skipped_students"] = skipped_students
            response["message"] += f", skipped {len(skipped_students)} students"
        
        return response
        
    except HTTPException as he:
        print(f"HTTP Exception: {he.detail}")
        db.rollback()
        raise
    except Exception as e:
        print(f"Unexpected error: {str(e)}")
        import traceback
        traceback.print_exc()
        db.rollback()
        raise HTTPException(status_code=500, detail=f"Error processing students: {str(e)}")

@router.post('/addData/')
async def addSingleStudentData(groupID: int, courseID: int, courseCode: str, studentID: int, db: Session = Depends(get_db)):
    try:
        print(f"Processing single student data for studentID: {studentID}")
        
        # Check if there are any survey responses at all
        survey_data = await get_data(groupID=groupID, courseID=courseID, db=db)
        if not survey_data:
            raise HTTPException(status_code=400, detail="No survey responses found for this group. Students must complete evaluations first.")
        
        # Calculate factors
        denominatorw = await get_denominator(
            groupID=groupID, 
            courseID=courseID, 
            studentID=studentID,
            includeSelf=True, 
            db=db
        )
        
        factorw = await calculateFactor(
            groupID=groupID, 
            courseID=courseID, 
            studentID=studentID,
            denominator=denominatorw,
            includeSelf=True, 
            db=db
        )
        
        denominatorwo = await get_denominator(
            groupID=groupID, 
            courseID=courseID, 
            studentID=studentID,
            includeSelf=False, 
            db=db
        )
        
        factorwo = await calculateFactor(
            groupID=groupID, 
            courseID=courseID, 
            studentID=studentID,
            denominator=denominatorwo,
            includeSelf=False, 
            db=db
        )
        
        # Check if we got valid factors
        if factorwo is None or factorw is None:
            raise HTTPException(status_code=400, detail="Insufficient evaluation data for this student. Student may not have been evaluated by peers.")
        
        # Get student info
        student_row: Student = db.query(Student).filter(Student.id == studentID).first()
        if not student_row:
            raise HTTPException(status_code=404, detail="Student not found")
        
        # Create data model
        data: StudentAdjFactor = StudentAdjFactor(
            name=student_row.name,
            courseCode=courseCode,
            utorid=student_row.utorid,
            groupNumber=groupID,
            courseid=courseID,
            factorWithoutSelf=factorwo,
            factorWithSelf=factorw
        )
        
        # Save to database
        db_instance = StudentAdjustmentFactor(**data.model_dump())
        db.add(db_instance)
        db.commit()
        db.refresh(db_instance)
        
        return {
            "message": "Factor added to database successfully",
            "data": {
                "student_id": studentID,
                "name": student_row.name,
                "factorWithSelf": factorw,
                "factorWithoutSelf": factorwo
            }
        }
        
    except HTTPException as he:
        db.rollback()
        raise
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=500, detail=f"Error processing student data: {str(e)}")
</file>

<file path="backend/routers/test.py">
from fastapi import APIRouter, Depends
from dependencies.auth import validate_token

router = APIRouter()

@router.get("/protected-route")
async def protected_route(user: dict = Depends(validate_token)):
    return {
        "message": "Authenticated!",
        "user_info": {
            "sub": user.get("sub"),
            "email": user.get("email")
        }
    }
</file>

<file path="backend/schemas.py">
from pydantic import BaseModel

class StudentCreate(BaseModel):
    name: str
    email: str
    id: int
</file>

<file path="backend/utils.py">
from typing import Optional

import jwt
from fastapi import Depends, HTTPException, status
from fastapi.security import SecurityScopes, HTTPAuthorizationCredentials, HTTPBearer

from application.config import get_settings


class UnauthorizedException(HTTPException):
    def __init__(self, detail: str, **kwargs):
        """Returns HTTP 403"""
        super().__init__(status.HTTP_403_FORBIDDEN, detail=detail)


class UnauthenticatedException(HTTPException):
    def __init__(self):
        super().__init__(
            status_code=status.HTTP_401_UNAUTHORIZED, detail="Requires authentication"
        )


class VerifyToken:
    """Does all the token verification using PyJWT"""

    def __init__(self):
        self.config = get_settings()

        # This gets the JWKS from a given URL and does processing so you can
        # use any of the keys available
        jwks_url = f'https://{self.config.auth0_domain}/.well-known/jwks.json'
        self.jwks_client = jwt.PyJWKClient(jwks_url)

    async def verify(self,
                     security_scopes: SecurityScopes,
                     token: Optional[HTTPAuthorizationCredentials] = Depends(HTTPBearer())
                     ):
        if token is None:
            raise UnauthenticatedException

        # This gets the 'kid' from the passed token
        try:
            signing_key = self.jwks_client.get_signing_key_from_jwt(
                token.credentials
            ).key
        except jwt.exceptions.PyJWKClientError as error:
            raise UnauthorizedException(str(error))
        except jwt.exceptions.DecodeError as error:
            raise UnauthorizedException(str(error))

        try:
            payload = jwt.decode(
                token.credentials,
                signing_key,
                algorithms=self.config.auth0_algorithms,
                audience=self.config.auth0_api_audience,
                issuer=self.config.auth0_issuer,
            )
        except Exception as error:
            raise UnauthorizedException(str(error))

        if len(security_scopes.scopes) > 0:
            self._check_claims(payload, 'scope', security_scopes.scopes)

        return payload

    def _check_claims(self, payload, claim_name, expected_value):
        if claim_name not in payload:
            raise UnauthorizedException(detail=f'No claim "{claim_name}" found in token')

        payload_claim = payload[claim_name]

        if claim_name == 'scope':
            payload_claim = payload[claim_name].split(' ')

        for value in expected_value:
            if value not in payload_claim:
                raise UnauthorizedException(detail=f'Missing "{claim_name}" scope')
</file>

<file path="frontend/.gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
</file>

<file path="frontend/components.json">
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "src/app/globals.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}
</file>

<file path="frontend/next.config.ts">
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;
</file>

<file path="frontend/postcss.config.mjs">
const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;
</file>

<file path="frontend/public/file.svg">
<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>
</file>

<file path="frontend/public/globe.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>
</file>

<file path="frontend/public/next.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>
</file>

<file path="frontend/public/vercel.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>
</file>

<file path="frontend/public/window.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>
</file>

<file path="frontend/README.md">
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.
</file>

<file path="frontend/src/app/api/axiosClient.ts">
import axios from "axios";


const AxiosClient = axios.create({
  baseURL: 'http://127.0.0.1:8080/', // Your API base URL
  timeout: 10000, // Optional: set timeout
});


AxiosClient.interceptors.request.use(
  (config) => {
    // Get token from localStorage, Redux store, or context
    const token = localStorage.getItem('authToken');
    
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

export default AxiosClient;
</file>

<file path="frontend/src/app/authRedirect/authlogic.ts">
import { User } from "lucide-react";

interface User {
  id: number;
  name: string;
  email: string;
  auth0_id?: string;
  role: string;
}

export class AuthService{
    async getUserRole(sub: string): Promise<string | null>{
        
        const response = await fetch(`http://127.0.0.1:8080/users/by-auth0/${sub}`);
        const result: User = await response.json();

        return result.role;
    }
}
</file>

<file path="frontend/src/app/instructor/course/[courseID]/[groupID]/GroupStudentClient.tsx">
"use client";
import { useState, useEffect } from "react";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card"
import { useAuth0 } from "@auth0/auth0-react";

import { useUser } from "@/providers/user-provider";
import { useRouter, usePathname  } from 'next/navigation'
import { Group } from "next/dist/shared/lib/router/utils/route-regex";


interface StudentData{
    email: string;
    id: number;
    student_id: number;
    firstname: string;
    utorid: number;
    name: string;
    lastname: string;
}

interface Props{
  groupID: number;
}


const fetchGroups = async (groupID: number): Promise<StudentData[]> => {
    const url: URL = new URL("http://127.0.0.1:8080/group/groups");
    url.searchParams.append('groupID', groupID.toString());

    const response = await fetch(url, {
        method: "GET",
    });
    const data: StudentData[] = await response.json();
    return data;
}

const GroupStudentClient = ({ groupID } : Props) => {
    const { user } = useUser();
    const [students, setStudents] = useState<StudentData[]>([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);
    const pathname = usePathname();

    const router = useRouter();

    useEffect(() => {
        if (!user?.id) return;
        const lecturerId = user.id;
        const loadData = async () => {
            try {
                if (!user){
                    throw new Error("Uh Oh");
                }
                
                const studentdata: StudentData[] = await fetchGroups(groupID); 
                setStudents(studentdata);
                
                
            } catch (err) {
                setError(err instanceof Error ? err.message : "Failed to load students in group");
            } finally {
                setLoading(false);
            }
        };

        loadData();
    }, [user?.id]);

    if (loading) return <div>Loading students in group...</div>;
    if (error) return <div>Error: {error}</div>;



    return (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 p-4">
            {students.length > 0 ? (
                students.map((student) => (
                    
                    
                        <Card key={`${student.id}`} className="hover:shadow-lg transition-shadow">
                        
                        <CardHeader>
                            <CardTitle>{student.name}</CardTitle>
                            <CardDescription>Group: {groupID}</CardDescription>
                        </CardHeader>
                        <CardContent>
                            <p className="text-sm text-gray-600">
                                {student.email}
                            </p>
                        </CardContent>
                        <CardFooter>
                            <p>{student.utorid}</p>
                        </CardFooter>
                        
                    
                    </Card>

                
                    
                ))
            ) : (
                <div className="text-gray-500">No groups found for this course, ID = {groupID}</div>
            )}
        </div>
    );
    
    

}

export default GroupStudentClient;
</file>

<file path="frontend/src/app/instructor/course/[courseID]/columns.tsx">
"use client"

import { ColumnDef } from "@tanstack/react-table"

// This type is used to define the shape of our data.
// You can use a Zod schema here if you want.
export type Payment = {
  id: string
  amount: number
  status: "pending" | "processing" | "success" | "failed"
  email: string
}


export type StudentData = {
    utorid: string;
    fname: string;
    lname: string;
    email: string;
    status: "pending" | "submitted" | "not finished"
    studentNumber: number;
}
export const columns: ColumnDef<StudentData>[] = [
  {
    accessorKey: "status",
    header: "Status",
  },
  {
    accessorKey: "email",
    header: "Email",
  },
  {
    accessorKey: "utorid",
    header: "UTORID",
  },

  {
    accessorKey: "student_id",
    header: "Student Number",
  },

  {
    accessorKey: "firstname",
    header: "First Name",
  },

  {
    accessorKey: "lastname",
    header: "Last Name",
  },
]
</file>

<file path="frontend/src/app/instructor/course/[courseID]/CoursePageClient.tsx">
'use client';

import { useState, useEffect } from "react";
import { columns, StudentData } from "./columns";
import { DataTable } from "./studentTable";

interface Props {
  courseId: number;
}

const CoursePageClient =  ({ courseId }: Props) => {
  const [studentsInCourse, setStudentsInCourse] = useState<StudentData[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  //Get group number of student in student_group with group_id == groups
  useEffect(() => {
    const loadData = async () => {
      try {
        const response = await fetch(`http://127.0.0.1:8080/course/students?courseID=${courseId}`);
        if (!response.ok) throw new Error("Failed to fetch students");
        const data = await response.json();


        setStudentsInCourse(data);
      } catch (err) {
        setError(err instanceof Error ? err.message : "Unknown error");
      } finally {
        setLoading(false);
      }
    };

    loadData();
  }, [courseId]);

  if (loading) return <p>Loading...</p>;
  if (error) return <p>Error: {error}</p>;

  return (
    <div className="container mx-auto py-10">
      <DataTable columns={columns} data={studentsInCourse} />
    </div>
  );
};

export default CoursePageClient;
</file>

<file path="frontend/src/app/instructor/course/[courseID]/studentTable.tsx">
"use client"

import {
  ColumnDef,
  flexRender,
  getCoreRowModel,
  useReactTable,
} from "@tanstack/react-table"

import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table"

interface DataTableProps<TData, TValue> {
  columns: ColumnDef<TData, TValue>[]
  data: TData[]
}

export function DataTable<TData, TValue>({
  columns,
  data,
}: DataTableProps<TData, TValue>) {
  const table = useReactTable({
    data,
    columns,
    getCoreRowModel: getCoreRowModel(),
  })

  return (
    <div className="rounded-md border">
      <Table>
        <TableHeader>
          {table.getHeaderGroups().map((headerGroup) => (
            <TableRow key={headerGroup.id}>
              {headerGroup.headers.map((header) => {
                return (
                  <TableHead key={header.id}>
                    {header.isPlaceholder
                      ? null
                      : flexRender(
                          header.column.columnDef.header,
                          header.getContext()
                        )}
                  </TableHead>
                )
              })}
            </TableRow>
          ))}
        </TableHeader>
        <TableBody>
          {table.getRowModel().rows?.length ? (
            table.getRowModel().rows.map((row) => (
              <TableRow
                key={row.id}
                data-state={row.getIsSelected() && "selected"}
              >
                {row.getVisibleCells().map((cell) => (
                  <TableCell key={cell.id}>
                    {flexRender(cell.column.columnDef.cell, cell.getContext())}
                  </TableCell>
                ))}
              </TableRow>
            ))
          ) : (
            <TableRow>
              <TableCell colSpan={columns.length} className="h-24 text-center">
                No results.
              </TableCell>
            </TableRow>
          )}
        </TableBody>
      </Table>
    </div>
  )
}
</file>

<file path="frontend/src/app/instructor/layout.tsx">
import { AppSidebar } from "@/components/app-sidebar"
import { SidebarTrigger } from "@/components/ui/sidebar"

export default function Layout({ children }: { children: React.ReactNode }) {
  return (
    <>
      <AppSidebar />
      <main>
        <SidebarTrigger />
        {children}
      </main>
    </>
  )
}
</file>

<file path="frontend/src/app/student/group/page.tsx">
"use client";

import {
  Card,
  CardAction,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card"

import { useRouter } from "next/navigation";
const Group = () => {
  const router = useRouter();
  return (
    <div className="p-4">
      <h2 className="text-lg font-semibold mb-6">
        You have the following group members to evaluate:
      </h2>
      
      <div className="flex flex-col md:flex-row gap-6 md:gap-8 justify-between p-4">
        
        <Card className="flex-1">
          <button type="button" onClick={() => router.push(`/survey`)}>
          <CardHeader>
            <CardTitle>Group Member 1</CardTitle>
            <CardDescription>Group 2</CardDescription>
          </CardHeader>
          <CardContent>
            <p>STAC67</p>
          </CardContent>
            </button>
        </Card>
        


        
        <Card className="flex-1">
          <button type="button" onClick={() => router.push(`/survey/`)}>
          <CardHeader>
            <CardTitle>Group Member 2</CardTitle>
            <CardDescription>Group: 2</CardDescription>
          </CardHeader>
          <CardContent>
            <p>STAC67</p>
          </CardContent>
          </button>
        </Card>

       
        <Card className="flex-1">
           <button type="button" onClick={() => router.push(`/survey/`)}>
          <CardHeader>
            <CardTitle>Group Member 3</CardTitle>
            <CardDescription>Group: 2</CardDescription>
          </CardHeader>
          <CardContent>
            <p>STAC67</p>
          </CardContent>
          </button>
        </Card>
        
      </div>
    </div>
  );
};

export default Group;
</file>

<file path="frontend/src/app/student/layout.tsx">
import { AppSidebar } from "@/components/app-sidebar"
import { SidebarTrigger } from "@/components/ui/sidebar"

export default function Layout({ children }: { children: React.ReactNode }) {
  return (
    <>
      <AppSidebar />
      <main>
        <SidebarTrigger />
        {children}
      </main>
    </>
  )
}
</file>

<file path="frontend/src/app/test/page.tsx">
'use client'
import { useUser } from "@/providers/user-provider";

export default function UserProfile() {
  const { user, loading, error } = useUser();

  if (loading) return <div>Loading profile...</div>;
  if (error) return <div>Error: {error}</div>;
  if (!user) return <div>Please log in to view profile</div>;

  return (
    <div className="profile-card">
      <h2>{user.name}</h2>
      <p>Email: {user.email}</p>
      <p>User ID: {user.id}</p>
    </div>
  );
}
</file>

<file path="frontend/src/components/file-drop.tsx">
"use client";


import { useState, ChangeEvent, FormEvent } from "react";

const FileDrop = () => {
    const [selectedFile, setSelectedFile] = useState<File | null>(null);
    const [error, setError] = useState<string | null>(null);

    const handleSubmit = async (e: FormEvent<HTMLFormElement>) => {
        e.preventDefault();

        if (!selectedFile) {
            setError("Please select a file first");
            return;
        }

        const data = new FormData();
        data.append('file', selectedFile);

        try {
            const response = await fetch('http://127.0.0.1:8080/api/csv', {
                method: 'POST',
                body: data,
                headers: {
                    "cid": "CSCC01",

                    // "Content-Type" is automatically set by browser for FormData
                }
            });

            if (!response.ok) {
                const errorResult = await response.json();
                throw new Error(errorResult.error || 'Upload failed');
            }

            const result = await response.json();
            console.log("Upload successful:", result);
            setError(null);
            
        } catch (error: unknown) {
            const message = error instanceof Error 
                ? error.message 
                : "An unknown error occurred";
            console.error(`Upload error: ${message}`);
            setError(message);
        }
    };

    const handleFileChange = (e: ChangeEvent<HTMLInputElement>) => {
        setError(null);
        const files = e.target.files;
        
        if (files && files.length > 0) {
            setSelectedFile(files[0]);
        } else {
            setSelectedFile(null);
        }
    };

    return (
        <div>
            <form onSubmit={handleSubmit}>
                <input
                    type="file"
                    accept=".csv"
                    onChange={handleFileChange}
                />
                <button type="submit">Upload CSV</button>
            </form>
            
            {error && <div style={{ color: 'red', marginTop: '10px' }}>Error: {error}</div>}
        </div>
    );
};

export default FileDrop;
</file>

<file path="frontend/src/components/loginbutton.tsx">
import React from 'react';
import { useAuth0 } from '@auth0/auth0-react';

function LoginButton() {
  const {
    isAuthenticated,
    loginWithRedirect,
  } = useAuth0();

  return !isAuthenticated && (
     <button className="bg-blue-500 text-white px-6 py-3 rounded-lg text-lg hover:bg-blue-600" onClick={() => loginWithRedirect()}>Log in</button>
  );
}

export default LoginButton;
</file>

<file path="frontend/src/components/logoutbutton.tsx">
import React from "react";
import { useAuth0 } from "@auth0/auth0-react";

const LogoutButton = () => {
  const { logout } = useAuth0();

  return (
    <button onClick={() => logout({ logoutParams: { returnTo: window.location.origin } })}>
      Log Out
    </button>
  );
};

export default LogoutButton;
</file>

<file path="frontend/src/components/ui/AFTable.tsx">
import { useState, useEffect } from "react";

const AdjustmentFactorTable = () => {

}

export default AdjustmentFactorTable;
</file>

<file path="frontend/src/components/ui/button.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }
</file>

<file path="frontend/src/components/ui/card.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

function Card({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card"
      className={cn(
        "bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm",
        className
      )}
      {...props}
    />
  )
}

function CardHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-header"
      className={cn(
        "@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6",
        className
      )}
      {...props}
    />
  )
}

function CardTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-title"
      className={cn("leading-none font-semibold", className)}
      {...props}
    />
  )
}

function CardDescription({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function CardAction({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-action"
      className={cn(
        "col-start-2 row-span-2 row-start-1 self-start justify-self-end",
        className
      )}
      {...props}
    />
  )
}

function CardContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-content"
      className={cn("px-6", className)}
      {...props}
    />
  )
}

function CardFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-footer"
      className={cn("flex items-center px-6 [.border-t]:pt-6", className)}
      {...props}
    />
  )
}

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardAction,
  CardDescription,
  CardContent,
}
</file>

<file path="frontend/src/components/ui/input.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props}
    />
  )
}

export { Input }
</file>

<file path="frontend/src/components/ui/separator.tsx">
"use client"

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

function Separator({
  className,
  orientation = "horizontal",
  decorative = true,
  ...props
}: React.ComponentProps<typeof SeparatorPrimitive.Root>) {
  return (
    <SeparatorPrimitive.Root
      data-slot="separator-root"
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px",
        className
      )}
      {...props}
    />
  )
}

export { Separator }
</file>

<file path="frontend/src/components/ui/sheet.tsx">
"use client"

import * as React from "react"
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Sheet({ ...props }: React.ComponentProps<typeof SheetPrimitive.Root>) {
  return <SheetPrimitive.Root data-slot="sheet" {...props} />
}

function SheetTrigger({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Trigger>) {
  return <SheetPrimitive.Trigger data-slot="sheet-trigger" {...props} />
}

function SheetClose({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Close>) {
  return <SheetPrimitive.Close data-slot="sheet-close" {...props} />
}

function SheetPortal({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Portal>) {
  return <SheetPrimitive.Portal data-slot="sheet-portal" {...props} />
}

function SheetOverlay({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Overlay>) {
  return (
    <SheetPrimitive.Overlay
      data-slot="sheet-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function SheetContent({
  className,
  children,
  side = "right",
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Content> & {
  side?: "top" | "right" | "bottom" | "left"
}) {
  return (
    <SheetPortal>
      <SheetOverlay />
      <SheetPrimitive.Content
        data-slot="sheet-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out fixed z-50 flex flex-col gap-4 shadow-lg transition ease-in-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
          side === "right" &&
            "data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right inset-y-0 right-0 h-full w-3/4 border-l sm:max-w-sm",
          side === "left" &&
            "data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left inset-y-0 left-0 h-full w-3/4 border-r sm:max-w-sm",
          side === "top" &&
            "data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top inset-x-0 top-0 h-auto border-b",
          side === "bottom" &&
            "data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom inset-x-0 bottom-0 h-auto border-t",
          className
        )}
        {...props}
      >
        {children}
        <SheetPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-secondary absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none">
          <XIcon className="size-4" />
          <span className="sr-only">Close</span>
        </SheetPrimitive.Close>
      </SheetPrimitive.Content>
    </SheetPortal>
  )
}

function SheetHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sheet-header"
      className={cn("flex flex-col gap-1.5 p-4", className)}
      {...props}
    />
  )
}

function SheetFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sheet-footer"
      className={cn("mt-auto flex flex-col gap-2 p-4", className)}
      {...props}
    />
  )
}

function SheetTitle({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Title>) {
  return (
    <SheetPrimitive.Title
      data-slot="sheet-title"
      className={cn("text-foreground font-semibold", className)}
      {...props}
    />
  )
}

function SheetDescription({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Description>) {
  return (
    <SheetPrimitive.Description
      data-slot="sheet-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Sheet,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}
</file>

<file path="frontend/src/components/ui/sidebar.tsx">
"use client"

import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { VariantProps, cva } from "class-variance-authority"
import { PanelLeftIcon } from "lucide-react"

import { useIsMobile } from "@/hooks/use-mobile"
import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Separator } from "@/components/ui/separator"
import {
  Sheet,
  SheetContent,
  SheetDescription,
  SheetHeader,
  SheetTitle,
} from "@/components/ui/sheet"
import { Skeleton } from "@/components/ui/skeleton"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip"

const SIDEBAR_COOKIE_NAME = "sidebar_state"
const SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7
const SIDEBAR_WIDTH = "16rem"
const SIDEBAR_WIDTH_MOBILE = "18rem"
const SIDEBAR_WIDTH_ICON = "3rem"
const SIDEBAR_KEYBOARD_SHORTCUT = "b"

type SidebarContextProps = {
  state: "expanded" | "collapsed"
  open: boolean
  setOpen: (open: boolean) => void
  openMobile: boolean
  setOpenMobile: (open: boolean) => void
  isMobile: boolean
  toggleSidebar: () => void
}

const SidebarContext = React.createContext<SidebarContextProps | null>(null)

function useSidebar() {
  const context = React.useContext(SidebarContext)
  if (!context) {
    throw new Error("useSidebar must be used within a SidebarProvider.")
  }

  return context
}

function SidebarProvider({
  defaultOpen = true,
  open: openProp,
  onOpenChange: setOpenProp,
  className,
  style,
  children,
  ...props
}: React.ComponentProps<"div"> & {
  defaultOpen?: boolean
  open?: boolean
  onOpenChange?: (open: boolean) => void
}) {
  const isMobile = useIsMobile()
  const [openMobile, setOpenMobile] = React.useState(false)

  // This is the internal state of the sidebar.
  // We use openProp and setOpenProp for control from outside the component.
  const [_open, _setOpen] = React.useState(defaultOpen)
  const open = openProp ?? _open
  const setOpen = React.useCallback(
    (value: boolean | ((value: boolean) => boolean)) => {
      const openState = typeof value === "function" ? value(open) : value
      if (setOpenProp) {
        setOpenProp(openState)
      } else {
        _setOpen(openState)
      }

      // This sets the cookie to keep the sidebar state.
      document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`
    },
    [setOpenProp, open]
  )

  // Helper to toggle the sidebar.
  const toggleSidebar = React.useCallback(() => {
    return isMobile ? setOpenMobile((open) => !open) : setOpen((open) => !open)
  }, [isMobile, setOpen, setOpenMobile])

  // Adds a keyboard shortcut to toggle the sidebar.
  React.useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (
        event.key === SIDEBAR_KEYBOARD_SHORTCUT &&
        (event.metaKey || event.ctrlKey)
      ) {
        event.preventDefault()
        toggleSidebar()
      }
    }

    window.addEventListener("keydown", handleKeyDown)
    return () => window.removeEventListener("keydown", handleKeyDown)
  }, [toggleSidebar])

  // We add a state so that we can do data-state="expanded" or "collapsed".
  // This makes it easier to style the sidebar with Tailwind classes.
  const state = open ? "expanded" : "collapsed"

  const contextValue = React.useMemo<SidebarContextProps>(
    () => ({
      state,
      open,
      setOpen,
      isMobile,
      openMobile,
      setOpenMobile,
      toggleSidebar,
    }),
    [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar]
  )

  return (
    <SidebarContext.Provider value={contextValue}>
      <TooltipProvider delayDuration={0}>
        <div
          data-slot="sidebar-wrapper"
          style={
            {
              "--sidebar-width": SIDEBAR_WIDTH,
              "--sidebar-width-icon": SIDEBAR_WIDTH_ICON,
              ...style,
            } as React.CSSProperties
          }
          className={cn(
            "group/sidebar-wrapper has-data-[variant=inset]:bg-sidebar flex min-h-svh w-full",
            className
          )}
          {...props}
        >
          {children}
        </div>
      </TooltipProvider>
    </SidebarContext.Provider>
  )
}

function Sidebar({
  side = "left",
  variant = "sidebar",
  collapsible = "offcanvas",
  className,
  children,
  ...props
}: React.ComponentProps<"div"> & {
  side?: "left" | "right"
  variant?: "sidebar" | "floating" | "inset"
  collapsible?: "offcanvas" | "icon" | "none"
}) {
  const { isMobile, state, openMobile, setOpenMobile } = useSidebar()

  if (collapsible === "none") {
    return (
      <div
        data-slot="sidebar"
        className={cn(
          "bg-sidebar text-sidebar-foreground flex h-full w-(--sidebar-width) flex-col",
          className
        )}
        {...props}
      >
        {children}
      </div>
    )
  }

  if (isMobile) {
    return (
      <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>
        <SheetContent
          data-sidebar="sidebar"
          data-slot="sidebar"
          data-mobile="true"
          className="bg-sidebar text-sidebar-foreground w-(--sidebar-width) p-0 [&>button]:hidden"
          style={
            {
              "--sidebar-width": SIDEBAR_WIDTH_MOBILE,
            } as React.CSSProperties
          }
          side={side}
        >
          <SheetHeader className="sr-only">
            <SheetTitle>Sidebar</SheetTitle>
            <SheetDescription>Displays the mobile sidebar.</SheetDescription>
          </SheetHeader>
          <div className="flex h-full w-full flex-col">{children}</div>
        </SheetContent>
      </Sheet>
    )
  }

  return (
    <div
      className="group peer text-sidebar-foreground hidden md:block"
      data-state={state}
      data-collapsible={state === "collapsed" ? collapsible : ""}
      data-variant={variant}
      data-side={side}
      data-slot="sidebar"
    >
      {/* This is what handles the sidebar gap on desktop */}
      <div
        data-slot="sidebar-gap"
        className={cn(
          "relative w-(--sidebar-width) bg-transparent transition-[width] duration-200 ease-linear",
          "group-data-[collapsible=offcanvas]:w-0",
          "group-data-[side=right]:rotate-180",
          variant === "floating" || variant === "inset"
            ? "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+(--spacing(4)))]"
            : "group-data-[collapsible=icon]:w-(--sidebar-width-icon)"
        )}
      />
      <div
        data-slot="sidebar-container"
        className={cn(
          "fixed inset-y-0 z-10 hidden h-svh w-(--sidebar-width) transition-[left,right,width] duration-200 ease-linear md:flex",
          side === "left"
            ? "left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]"
            : "right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]",
          // Adjust the padding for floating and inset variants.
          variant === "floating" || variant === "inset"
            ? "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+(--spacing(4))+2px)]"
            : "group-data-[collapsible=icon]:w-(--sidebar-width-icon) group-data-[side=left]:border-r group-data-[side=right]:border-l",
          className
        )}
        {...props}
      >
        <div
          data-sidebar="sidebar"
          data-slot="sidebar-inner"
          className="bg-sidebar group-data-[variant=floating]:border-sidebar-border flex h-full w-full flex-col group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:shadow-sm"
        >
          {children}
        </div>
      </div>
    </div>
  )
}

function SidebarTrigger({
  className,
  onClick,
  ...props
}: React.ComponentProps<typeof Button>) {
  const { toggleSidebar } = useSidebar()

  return (
    <Button
      data-sidebar="trigger"
      data-slot="sidebar-trigger"
      variant="ghost"
      size="icon"
      className={cn("size-7", className)}
      onClick={(event) => {
        onClick?.(event)
        toggleSidebar()
      }}
      {...props}
    >
      <PanelLeftIcon />
      <span className="sr-only">Toggle Sidebar</span>
    </Button>
  )
}

function SidebarRail({ className, ...props }: React.ComponentProps<"button">) {
  const { toggleSidebar } = useSidebar()

  return (
    <button
      data-sidebar="rail"
      data-slot="sidebar-rail"
      aria-label="Toggle Sidebar"
      tabIndex={-1}
      onClick={toggleSidebar}
      title="Toggle Sidebar"
      className={cn(
        "hover:after:bg-sidebar-border absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear group-data-[side=left]:-right-4 group-data-[side=right]:left-0 after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] sm:flex",
        "in-data-[side=left]:cursor-w-resize in-data-[side=right]:cursor-e-resize",
        "[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize",
        "hover:group-data-[collapsible=offcanvas]:bg-sidebar group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full",
        "[[data-side=left][data-collapsible=offcanvas]_&]:-right-2",
        "[[data-side=right][data-collapsible=offcanvas]_&]:-left-2",
        className
      )}
      {...props}
    />
  )
}

function SidebarInset({ className, ...props }: React.ComponentProps<"main">) {
  return (
    <main
      data-slot="sidebar-inset"
      className={cn(
        "bg-background relative flex w-full flex-1 flex-col",
        "md:peer-data-[variant=inset]:m-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow-sm md:peer-data-[variant=inset]:peer-data-[state=collapsed]:ml-2",
        className
      )}
      {...props}
    />
  )
}

function SidebarInput({
  className,
  ...props
}: React.ComponentProps<typeof Input>) {
  return (
    <Input
      data-slot="sidebar-input"
      data-sidebar="input"
      className={cn("bg-background h-8 w-full shadow-none", className)}
      {...props}
    />
  )
}

function SidebarHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-header"
      data-sidebar="header"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
}

function SidebarFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-footer"
      data-sidebar="footer"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
}

function SidebarSeparator({
  className,
  ...props
}: React.ComponentProps<typeof Separator>) {
  return (
    <Separator
      data-slot="sidebar-separator"
      data-sidebar="separator"
      className={cn("bg-sidebar-border mx-2 w-auto", className)}
      {...props}
    />
  )
}

function SidebarContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-content"
      data-sidebar="content"
      className={cn(
        "flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden",
        className
      )}
      {...props}
    />
  )
}

function SidebarGroup({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-group"
      data-sidebar="group"
      className={cn("relative flex w-full min-w-0 flex-col p-2", className)}
      {...props}
    />
  )
}

function SidebarGroupLabel({
  className,
  asChild = false,
  ...props
}: React.ComponentProps<"div"> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "div"

  return (
    <Comp
      data-slot="sidebar-group-label"
      data-sidebar="group-label"
      className={cn(
        "text-sidebar-foreground/70 ring-sidebar-ring flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium outline-hidden transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        "group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0",
        className
      )}
      {...props}
    />
  )
}

function SidebarGroupAction({
  className,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="sidebar-group-action"
      data-sidebar="group-action"
      className={cn(
        "text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground absolute top-3.5 right-3 flex aspect-square w-5 items-center justify-center rounded-md p-0 outline-hidden transition-transform focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 md:after:hidden",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
}

function SidebarGroupContent({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-group-content"
      data-sidebar="group-content"
      className={cn("w-full text-sm", className)}
      {...props}
    />
  )
}

function SidebarMenu({ className, ...props }: React.ComponentProps<"ul">) {
  return (
    <ul
      data-slot="sidebar-menu"
      data-sidebar="menu"
      className={cn("flex w-full min-w-0 flex-col gap-1", className)}
      {...props}
    />
  )
}

function SidebarMenuItem({ className, ...props }: React.ComponentProps<"li">) {
  return (
    <li
      data-slot="sidebar-menu-item"
      data-sidebar="menu-item"
      className={cn("group/menu-item relative", className)}
      {...props}
    />
  )
}

const sidebarMenuButtonVariants = cva(
  "peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-hidden ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground",
        outline:
          "bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]",
      },
      size: {
        default: "h-8 text-sm",
        sm: "h-7 text-xs",
        lg: "h-12 text-sm group-data-[collapsible=icon]:p-0!",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function SidebarMenuButton({
  asChild = false,
  isActive = false,
  variant = "default",
  size = "default",
  tooltip,
  className,
  ...props
}: React.ComponentProps<"button"> & {
  asChild?: boolean
  isActive?: boolean
  tooltip?: string | React.ComponentProps<typeof TooltipContent>
} & VariantProps<typeof sidebarMenuButtonVariants>) {
  const Comp = asChild ? Slot : "button"
  const { isMobile, state } = useSidebar()

  const button = (
    <Comp
      data-slot="sidebar-menu-button"
      data-sidebar="menu-button"
      data-size={size}
      data-active={isActive}
      className={cn(sidebarMenuButtonVariants({ variant, size }), className)}
      {...props}
    />
  )

  if (!tooltip) {
    return button
  }

  if (typeof tooltip === "string") {
    tooltip = {
      children: tooltip,
    }
  }

  return (
    <Tooltip>
      <TooltipTrigger asChild>{button}</TooltipTrigger>
      <TooltipContent
        side="right"
        align="center"
        hidden={state !== "collapsed" || isMobile}
        {...tooltip}
      />
    </Tooltip>
  )
}

function SidebarMenuAction({
  className,
  asChild = false,
  showOnHover = false,
  ...props
}: React.ComponentProps<"button"> & {
  asChild?: boolean
  showOnHover?: boolean
}) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="sidebar-menu-action"
      data-sidebar="menu-action"
      className={cn(
        "text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground peer-hover/menu-button:text-sidebar-accent-foreground absolute top-1.5 right-1 flex aspect-square w-5 items-center justify-center rounded-md p-0 outline-hidden transition-transform focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 md:after:hidden",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        showOnHover &&
          "peer-data-[active=true]/menu-button:text-sidebar-accent-foreground group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 md:opacity-0",
        className
      )}
      {...props}
    />
  )
}

function SidebarMenuBadge({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-menu-badge"
      data-sidebar="menu-badge"
      className={cn(
        "text-sidebar-foreground pointer-events-none absolute right-1 flex h-5 min-w-5 items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums select-none",
        "peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
}

function SidebarMenuSkeleton({
  className,
  showIcon = false,
  ...props
}: React.ComponentProps<"div"> & {
  showIcon?: boolean
}) {
  // Random width between 50 to 90%.
  const width = React.useMemo(() => {
    return `${Math.floor(Math.random() * 40) + 50}%`
  }, [])

  return (
    <div
      data-slot="sidebar-menu-skeleton"
      data-sidebar="menu-skeleton"
      className={cn("flex h-8 items-center gap-2 rounded-md px-2", className)}
      {...props}
    >
      {showIcon && (
        <Skeleton
          className="size-4 rounded-md"
          data-sidebar="menu-skeleton-icon"
        />
      )}
      <Skeleton
        className="h-4 max-w-(--skeleton-width) flex-1"
        data-sidebar="menu-skeleton-text"
        style={
          {
            "--skeleton-width": width,
          } as React.CSSProperties
        }
      />
    </div>
  )
}

function SidebarMenuSub({ className, ...props }: React.ComponentProps<"ul">) {
  return (
    <ul
      data-slot="sidebar-menu-sub"
      data-sidebar="menu-sub"
      className={cn(
        "border-sidebar-border mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l px-2.5 py-0.5",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
}

function SidebarMenuSubItem({
  className,
  ...props
}: React.ComponentProps<"li">) {
  return (
    <li
      data-slot="sidebar-menu-sub-item"
      data-sidebar="menu-sub-item"
      className={cn("group/menu-sub-item relative", className)}
      {...props}
    />
  )
}

function SidebarMenuSubButton({
  asChild = false,
  size = "md",
  isActive = false,
  className,
  ...props
}: React.ComponentProps<"a"> & {
  asChild?: boolean
  size?: "sm" | "md"
  isActive?: boolean
}) {
  const Comp = asChild ? Slot : "a"

  return (
    <Comp
      data-slot="sidebar-menu-sub-button"
      data-sidebar="menu-sub-button"
      data-size={size}
      data-active={isActive}
      className={cn(
        "text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground active:bg-sidebar-accent active:text-sidebar-accent-foreground [&>svg]:text-sidebar-accent-foreground flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 outline-hidden focus-visible:ring-2 disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
        "data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground",
        size === "sm" && "text-xs",
        size === "md" && "text-sm",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
}

export {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupAction,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarHeader,
  SidebarInput,
  SidebarInset,
  SidebarMenu,
  SidebarMenuAction,
  SidebarMenuBadge,
  SidebarMenuButton,
  SidebarMenuItem,
  SidebarMenuSkeleton,
  SidebarMenuSub,
  SidebarMenuSubButton,
  SidebarMenuSubItem,
  SidebarProvider,
  SidebarRail,
  SidebarSeparator,
  SidebarTrigger,
  useSidebar,
}
</file>

<file path="frontend/src/components/ui/skeleton.tsx">
import { cn } from "@/lib/utils"

function Skeleton({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="skeleton"
      className={cn("bg-accent animate-pulse rounded-md", className)}
      {...props}
    />
  )
}

export { Skeleton }
</file>

<file path="frontend/src/components/ui/table.tsx">
"use client"

import * as React from "react"

import { cn } from "@/lib/utils"

function Table({ className, ...props }: React.ComponentProps<"table">) {
  return (
    <div
      data-slot="table-container"
      className="relative w-full overflow-x-auto"
    >
      <table
        data-slot="table"
        className={cn("w-full caption-bottom text-sm", className)}
        {...props}
      />
    </div>
  )
}

function TableHeader({ className, ...props }: React.ComponentProps<"thead">) {
  return (
    <thead
      data-slot="table-header"
      className={cn("[&_tr]:border-b", className)}
      {...props}
    />
  )
}

function TableBody({ className, ...props }: React.ComponentProps<"tbody">) {
  return (
    <tbody
      data-slot="table-body"
      className={cn("[&_tr:last-child]:border-0", className)}
      {...props}
    />
  )
}

function TableFooter({ className, ...props }: React.ComponentProps<"tfoot">) {
  return (
    <tfoot
      data-slot="table-footer"
      className={cn(
        "bg-muted/50 border-t font-medium [&>tr]:last:border-b-0",
        className
      )}
      {...props}
    />
  )
}

function TableRow({ className, ...props }: React.ComponentProps<"tr">) {
  return (
    <tr
      data-slot="table-row"
      className={cn(
        "hover:bg-muted/50 data-[state=selected]:bg-muted border-b transition-colors",
        className
      )}
      {...props}
    />
  )
}

function TableHead({ className, ...props }: React.ComponentProps<"th">) {
  return (
    <th
      data-slot="table-head"
      className={cn(
        "text-foreground h-10 px-2 text-left align-middle font-medium whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
        className
      )}
      {...props}
    />
  )
}

function TableCell({ className, ...props }: React.ComponentProps<"td">) {
  return (
    <td
      data-slot="table-cell"
      className={cn(
        "p-2 align-middle whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
        className
      )}
      {...props}
    />
  )
}

function TableCaption({
  className,
  ...props
}: React.ComponentProps<"caption">) {
  return (
    <caption
      data-slot="table-caption"
      className={cn("text-muted-foreground mt-4 text-sm", className)}
      {...props}
    />
  )
}

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}
</file>

<file path="frontend/src/components/ui/tooltip.tsx">
"use client"

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

function TooltipProvider({
  delayDuration = 0,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Provider>) {
  return (
    <TooltipPrimitive.Provider
      data-slot="tooltip-provider"
      delayDuration={delayDuration}
      {...props}
    />
  )
}

function Tooltip({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Root>) {
  return (
    <TooltipProvider>
      <TooltipPrimitive.Root data-slot="tooltip" {...props} />
    </TooltipProvider>
  )
}

function TooltipTrigger({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Trigger>) {
  return <TooltipPrimitive.Trigger data-slot="tooltip-trigger" {...props} />
}

function TooltipContent({
  className,
  sideOffset = 0,
  children,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Content>) {
  return (
    <TooltipPrimitive.Portal>
      <TooltipPrimitive.Content
        data-slot="tooltip-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-primary text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-fit origin-(--radix-tooltip-content-transform-origin) rounded-md px-3 py-1.5 text-xs text-balance",
          className
        )}
        {...props}
      >
        {children}
        <TooltipPrimitive.Arrow className="bg-primary fill-primary z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px]" />
      </TooltipPrimitive.Content>
    </TooltipPrimitive.Portal>
  )
}

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }
</file>

<file path="frontend/src/hooks/use-mobile.ts">
import * as React from "react"

const MOBILE_BREAKPOINT = 768

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    mql.addEventListener("change", onChange)
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    return () => mql.removeEventListener("change", onChange)
  }, [])

  return !!isMobile
}
</file>

<file path="frontend/src/lib/api.ts">
export async function fetchWithAuth(url: string, options: RequestInit = {}) {
  const token = localStorage.getItem('session_token');
  
  const headers = {
    ...options.headers,
    'Authorization': `Bearer ${token}`
  };

  const response = await fetch(url, { ...options, headers });
  
  if (response.status === 401) {
    // Handle token expiration
    localStorage.removeItem('session_token');
    window.location.reload();
  }
  
  return response;
}
</file>

<file path="frontend/src/lib/utils.ts">
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
</file>

<file path="frontend/src/providers/auth-provider.tsx">
// src/providers/auth-provider.tsx
'use client';
import { Auth0Provider } from '@auth0/auth0-react';
import { ReactNode } from 'react';

// Create a separate component for user sync
import UserSync from './user-sync'; // We'll create this next
import { UserProvider } from './user-provider';
export default function AuthProvider({ children }: { children: ReactNode }) {
  return (
    <Auth0Provider
      domain="dev-4m08esq3iy51y7tm.us.auth0.com"
      clientId="CUktNfrC91Xqi7MtIZoPUtqCFVoWWKYW"
      authorizationParams={{
        redirect_uri: typeof window !== 'undefined' ? window.location.origin : '',
        audience: "https://peerassessment.com",
        scope: 'openid profile email',
      }}
      cacheLocation="localstorage"
      useRefreshTokens={true}
    >
      {/* Wrap children with UserSync component */}
      <UserProvider>{children}</UserProvider>
    </Auth0Provider>
  );
}
</file>

<file path="frontend/src/providers/user-sync.tsx">
// src/providers/user-sync.tsx
'use client';
import { useAuth0 } from '@auth0/auth0-react';
import { useEffect } from 'react';

export default function UserSync({ children }: { children: React.ReactNode }) {
  const { user, isAuthenticated, getAccessTokenSilently } = useAuth0();

  // Sync user with FastAPI backend
  useEffect(() => {
    const syncUser = async () => {
      if (!isAuthenticated || !user) return;
      
      try {
        const token = await getAccessTokenSilently();
        
        await fetch('http://127.0.0.1:8080/users', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          },
          body: JSON.stringify({
            sub: user.sub,
            email: user.email,
            name: user.name,
            // Add any additional claims
          })
        });
      } catch (error) {
        console.error('User sync failed:', error);
      }
    };

    syncUser();
  }, [isAuthenticated, user, getAccessTokenSilently]);

  return <>{children}</>;
}
</file>

<file path="frontend/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2025 shawnjiang1019

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="README.md">
# Peer Assessment
</file>

<file path="thing.py">
import http.client

conn = http.client.HTTPSConnection("dev-4m08esq3iy51y7tm.us.auth0.com")

payload = "{\"client_id\":\"PBQnnApGyNMQWOrnQgGJQtyViuOgf6pJ\",\"client_secret\":\"WRPTW8ebD_hvUDwB6AKos7S-1xL7PygYvOWp147gvpKpclO9D214CjdCpJb0yOJk\",\"audience\":\"https://peerassessment.com\",\"grant_type\":\"client_credentials\"}"

headers = { 'content-type': "application/json" }

conn.request("POST", "/oauth/token", payload, headers)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
</file>

<file path="backend/alembic.ini">
# A generic, single database configuration.

[alembic]
# path to migration scripts.
# this is typically a path given in POSIX (e.g. forward slashes)
# format, relative to the token %(here)s which refers to the location of this
# ini file
script_location = %(here)s/migrations

# template used to generate migration file names; The default value is %%(rev)s_%%(slug)s
# Uncomment the line below if you want the files to be prepended with date and time
# see https://alembic.sqlalchemy.org/en/latest/tutorial.html#editing-the-ini-file
# for all available tokens
# file_template = %%(year)d_%%(month).2d_%%(day).2d_%%(hour).2d%%(minute).2d-%%(rev)s_%%(slug)s

# sys.path path, will be prepended to sys.path if present.
# defaults to the current working directory.  for multiple paths, the path separator
# is defined by "path_separator" below.
prepend_sys_path = .


# timezone to use when rendering the date within the migration file
# as well as the filename.
# If specified, requires the python>=3.9 or backports.zoneinfo library and tzdata library.
# Any required deps can installed by adding `alembic[tz]` to the pip requirements
# string value is passed to ZoneInfo()
# leave blank for localtime
# timezone =

# max length of characters to apply to the "slug" field
# truncate_slug_length = 40

# set to 'true' to run the environment during
# the 'revision' command, regardless of autogenerate
# revision_environment = false

# set to 'true' to allow .pyc and .pyo files without
# a source .py file to be detected as revisions in the
# versions/ directory
# sourceless = false

# version location specification; This defaults
# to <script_location>/versions.  When using multiple version
# directories, initial revisions must be specified with --version-path.
# The path separator used here should be the separator specified by "path_separator"
# below.
# version_locations = %(here)s/bar:%(here)s/bat:%(here)s/alembic/versions

# path_separator; This indicates what character is used to split lists of file
# paths, including version_locations and prepend_sys_path within configparser
# files such as alembic.ini.
# The default rendered in new alembic.ini files is "os", which uses os.pathsep
# to provide os-dependent path splitting.
#
# Note that in order to support legacy alembic.ini files, this default does NOT
# take place if path_separator is not present in alembic.ini.  If this
# option is omitted entirely, fallback logic is as follows:
#
# 1. Parsing of the version_locations option falls back to using the legacy
#    "version_path_separator" key, which if absent then falls back to the legacy
#    behavior of splitting on spaces and/or commas.
# 2. Parsing of the prepend_sys_path option falls back to the legacy
#    behavior of splitting on spaces, commas, or colons.
#
# Valid values for path_separator are:
#
# path_separator = :
# path_separator = ;
# path_separator = space
# path_separator = newline
#
# Use os.pathsep. Default configuration used for new projects.
path_separator = os

# set to 'true' to search source files recursively
# in each "version_locations" directory
# new in Alembic version 1.10
# recursive_version_locations = false

# the output encoding used when revision files
# are written from script.py.mako
# output_encoding = utf-8

# database URL.  This is consumed by the user-maintained env.py script only.
# other means of configuring database URLs may be customized within the env.py
# file.
sqlalchemy.url=postgresql://shawn:051671Dashui!@localhost:5432/peer


[post_write_hooks]
# post_write_hooks defines scripts or Python functions that are run
# on newly generated revision scripts.  See the documentation for further
# detail and examples

# format using "black" - use the console_scripts runner, against the "black" entrypoint
# hooks = black
# black.type = console_scripts
# black.entrypoint = black
# black.options = -l 79 REVISION_SCRIPT_FILENAME

# lint with attempts to fix using "ruff" - use the exec runner, execute a binary
# hooks = ruff
# ruff.type = exec
# ruff.executable = %(here)s/.venv/bin/ruff
# ruff.options = check --fix REVISION_SCRIPT_FILENAME

# Logging configuration.  This is also consumed by the user-maintained
# env.py script only.
[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARNING
handlers = console
qualname =

[logger_sqlalchemy]
level = WARNING
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s
datefmt = %H:%M:%S
</file>

<file path="backend/routers/calculations.py">
from fastapi import APIRouter, Depends, HTTPException
from models import SessionLocal, User, Course, Group, Student, StudentGroup, StudentCourse, StudentSurvey
from sqlalchemy.orm import Session
from pydantic import BaseModel
from typing import Optional, List
from models import get_db
from routers.groups import StudentSurveyBase
router = APIRouter()

#Helper functions


async def calculateStudentFactor(studentID: int, groupAverage: float, factor: str, studentAverage: float):
    '''
    Given the group average and student average for a 
    specified factor, calculates the adjustment factor 
    for the specified student for a certain factor
    '''
    adjfactor = studentAverage / groupAverage
    
    return {
        'studentID': studentID, 
        'adjfactor': adjfactor,
        'factor': factor
    }

async def calculateStudentAverageScore(data: List[StudentSurveyBase], factor: str):
    '''
    Calculates the average score for a single student for a single 
    factor given a list of their data points (student survey instances)
    '''
    averagescore: float = 0
    if len(data) == 0:
        return averagescore
    total: int = 0
    for datapoint in data:
        total = total + datapoint.answer

    averagescore = total / len(data)

    return averagescore

async def calculateGroupAverageScore(factor: str, data: List[StudentSurveyBase]):
    '''
    Calculates the average score for all students in a group
    given their average factors for a particular factor
    '''
    total = 0
    for datapoint in data:
        total = total + datapoint.answer
    groupAVG = total / len(data)
    return groupAVG


async def getSurveyData(courseID: int, groupID: int, db: Session = Depends(get_db)) -> List[StudentSurveyBase]:
    '''
    Get the raw survey data as student_survey rows for a given courseID
    and a given groupID, return as a list of StudentSurvey objects
    '''
    
    instances = db.query(StudentSurvey).filter(
        StudentSurvey.course_id == courseID,
        StudentSurvey.group_id == groupID
    ).all()
    if not instances:
        raise HTTPException(status_code=404, detail="No survey instances found for this group in this course")    
    return instances

async def getStudentSurveyData(courseID: int, groupID: int, studentID: int, data: List[StudentSurveyBase]) -> List[StudentSurveyBase]:
    filtered = [datapoint for datapoint in data if datapoint.evaluator_id == studentID and datapoint.group_id == groupID ]
    return filtered

@router.get('/factors')
async def findFactors(studentID: int, groupID: int, courseID: int, db: Session = Depends(get_db)):
    '''
    Get the factors for a given student in a given group for a given course
    '''
    factors = ["q1", "q2", "q3", "q4"]
    groupData: List[StudentSurveyBase] = await getSurveyData(courseID=courseID, groupID=groupID, db=db)
    studentData: List[StudentSurveyBase] = await getStudentSurveyData(courseID=courseID, groupID=groupID, studentID=studentID, data=groupData)
    factorDict = {}

    if len(groupData) == 0:
        raise HTTPException(status_code=404, detail="group data is null")    
    for factor in factors:
        groupFactorData = [datapoint for datapoint in groupData if datapoint.question_id == factor]
        if len(groupFactorData) == 0:
            raise HTTPException(status_code=404, detail="No survey instances found for this group in this course")    
        groupAvg = await calculateGroupAverageScore(factor=factor, data=groupFactorData)
        studentFactorData = [datapoint for datapoint in studentData if datapoint.question_id == factor]
        studentAvg = await calculateStudentAverageScore(factor=factor, data=studentFactorData)
        factorDict[factor] = studentAvg / groupAvg

    return factorDict
</file>

<file path="frontend/eslint.config.mjs">
// import { dirname } from "path";
// import { fileURLToPath } from "url";
// import { FlatCompat } from "@eslint/eslintrc";

// const __filename = fileURLToPath(import.meta.url);
// const __dirname = dirname(__filename);

// const compat = new FlatCompat({
//   baseDirectory: __dirname,
// });

// const eslintConfig = [
//   ...compat.extends("next/core-web-vitals", "next/typescript"),
// ];

// export default eslintConfig;

// eslint.config.mjs
import js from "@eslint/js";
import globals from "globals";
import tseslint from "typescript-eslint";
import eslintPluginReact from "eslint-plugin-react";
import eslintPluginReactHooks from "eslint-plugin-react-hooks";

export default [
  js.configs.recommended,
  ...tseslint.configs.recommended,
  {
    files: ["**/*.{ts,tsx}"],
    plugins: {
      "react-hooks": eslintPluginReactHooks,
      "react": eslintPluginReact
    },
    languageOptions: {
      globals: {
        ...globals.browser,
        ...globals.node
      },
      parserOptions: {
        ecmaFeatures: {
          jsx: true
        }
      }
    },
    rules: {
      // Downgrade these to warnings to unblock build
      "@typescript-eslint/no-unused-vars": "warn",
      "react-hooks/exhaustive-deps": "warn",
      
      // Fix empty interface error
      "@typescript-eslint/no-empty-object-type": "off",
      
      // Add other custom rules here
      "react/react-in-jsx-scope": "off",
      "react/prop-types": "off"
    }
  },
  {
    // Ignore these rules during build
    ignores: [
      "**/node_modules/**",
      "**/dist/**",
      "**/.next/**",
      "**/*.config.js"
    ]
  }
];
</file>

<file path="frontend/src/app/authRedirect/page.tsx">
'use client';
import { useEffect, useState } from "react";
import { useAuth0 } from "@auth0/auth0-react";
import { useRouter } from "next/navigation";
import { useUser } from "@/providers/user-provider";

const AuthRedirect = () => {
    const [isRedirecting, setIsRedirecting] = useState(false);
    const { isAuthenticated, isLoading: auth0Loading } = useAuth0();
    const { user, loading: userLoading, error } = useUser(); // Use context instead of API call
    const router = useRouter();

    useEffect(() => {
        const handleRedirect = async () => {
            // Wait for both Auth0 and user context to finish loading
            if (auth0Loading || userLoading || isRedirecting) {
                return;
            }

            if (!isAuthenticated) {
                router.push('/');
                return;
            }

            if (user) {
                try {
                    setIsRedirecting(true);
                    console.log('User role:', user.role);

                    switch (user.role) {
                        case 'instructor':
                            router.push('/instructor');
                            break;
                        case 'student':
                            router.push('/student');
                            break;
                        default:
                            router.push('/student');
                    }
                } catch (error) {
                    console.error('Error during redirect:', error);
                    // Fallback to student page on error
                    router.push('/student');
                } finally {
                    setIsRedirecting(false);
                }
            } else if (error) {
                console.error('User context error:', error);
                // Handle error case - maybe redirect to error page or fallback
                router.push('/student');
            }
        };

        handleRedirect();
    }, [user, isAuthenticated, auth0Loading, userLoading, router, isRedirecting, error]);

    // Show loading state while Auth0 is loading, user is loading, or while redirecting
    if (auth0Loading || userLoading || isRedirecting) {
        return (
            <div className="flex justify-center items-center min-h-screen">
                <div className="animate-pulse">
                    {auth0Loading ? 'Authenticating...' : 
                     userLoading ? 'Loading user data...' : 
                     'Redirecting...'}
                </div>
            </div>
        );
    }

    return null;
};

export default AuthRedirect;
</file>

<file path="frontend/src/app/globals.css">
@import "tailwindcss";
@import "tw-animate-css";

@custom-variant dark (&:is(.dark *));

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
  --color-sidebar-ring: var(--sidebar-ring);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar: var(--sidebar);
  --color-chart-5: var(--chart-5);
  --color-chart-4: var(--chart-4);
  --color-chart-3: var(--chart-3);
  --color-chart-2: var(--chart-2);
  --color-chart-1: var(--chart-1);
  --color-ring: var(--ring);
  --color-input: var(--input);
  --color-border: var(--border);
  --color-destructive: var(--destructive);
  --color-accent-foreground: var(--accent-foreground);
  --color-accent: var(--accent);
  --color-muted-foreground: var(--muted-foreground);
  --color-muted: var(--muted);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-secondary: var(--secondary);
  --color-primary-foreground: var(--primary-foreground);
  --color-primary: var(--primary);
  --color-popover-foreground: var(--popover-foreground);
  --color-popover: var(--popover);
  --color-card-foreground: var(--card-foreground);
  --color-card: var(--card);
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
}

:root {
  --radius: 0.625rem;
  --background: oklch(1 0 0);
  --foreground: oklch(0.145 0 0);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.145 0 0);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.145 0 0);
  --primary: oklch(0.205 0 0);
  --primary-foreground: oklch(0.985 0 0);
  --secondary: oklch(0.97 0 0);
  --secondary-foreground: oklch(0.205 0 0);
  --muted: oklch(0.97 0 0);
  --muted-foreground: oklch(0.556 0 0);
  --accent: oklch(0.97 0 0);
  --accent-foreground: oklch(0.205 0 0);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.922 0 0);
  --input: oklch(0.922 0 0);
  --ring: oklch(0.708 0 0);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.985 0 0);
  --sidebar-foreground: oklch(0.145 0 0);
  --sidebar-primary: oklch(0.205 0 0);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.97 0 0);
  --sidebar-accent-foreground: oklch(0.205 0 0);
  --sidebar-border: oklch(0.922 0 0);
  --sidebar-ring: oklch(0.708 0 0);
}

.dark {
  --background: oklch(0.145 0 0);
  --foreground: oklch(0.985 0 0);
  --card: oklch(0.205 0 0);
  --card-foreground: oklch(0.985 0 0);
  --popover: oklch(0.205 0 0);
  --popover-foreground: oklch(0.985 0 0);
  --primary: oklch(0.922 0 0);
  --primary-foreground: oklch(0.205 0 0);
  --secondary: oklch(0.269 0 0);
  --secondary-foreground: oklch(0.985 0 0);
  --muted: oklch(0.269 0 0);
  --muted-foreground: oklch(0.708 0 0);
  --accent: oklch(0.269 0 0);
  --accent-foreground: oklch(0.985 0 0);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.556 0 0);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.205 0 0);
  --sidebar-foreground: oklch(0.985 0 0);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.269 0 0);
  --sidebar-accent-foreground: oklch(0.985 0 0);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.556 0 0);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}
</file>

<file path="frontend/src/app/instructor/course/[courseID]/GroupClient.tsx">
"use client";
import { useState, useEffect } from "react";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card"
import { useAuth0 } from "@auth0/auth0-react";
import { useUser } from "@/providers/user-provider";
import { useRouter, usePathname } from 'next/navigation'
import { AppRouterInstance } from "next/dist/shared/lib/app-router-context.shared-runtime";

interface GroupData {
  courseCode: string;
  courseID: string;  // Consider renaming to courseId for consistency
  groupNumber: number;
  id: number;
}

type GroupsProps = {
  courseId: number;
};

const fetchGroups = async (courseID: number): Promise<GroupData[]> => {
  const url = new URL("http://127.0.0.1:8080/group/getgroups");
  url.searchParams.append('courseID', courseID.toString());
  
  const response = await fetch(url, { method: "GET" });
  return await response.json();
}

const Groups = ({ courseId }: GroupsProps) => {  // Fixed props destructuring
  const { user } = useUser();
  const [groups, setGroups] = useState<GroupData[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const router: AppRouterInstance = useRouter();
  const pathname: string = usePathname();

  useEffect(() => {
    if (!user?.id) return;
    
    const loadData = async () => {
      try {
        const groupdata = await fetchGroups(courseId);
        setGroups(groupdata);
      } catch (err) {
        setError(err instanceof Error ? err.message : "Failed to load groups");
      } finally {
        setLoading(false);
      }
    };

    loadData();
  }, [user?.id, courseId]);  // Added courseId to dependencies

  if (loading) return <div>Loading groups...</div>;
  if (error) return <div>Error: {error}</div>;

  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 p-4">
      {groups.length > 0 ? (
        groups.map((group) => (
          <Card key={group.id} className="hover:shadow-lg transition-shadow">
            <button 
              type="button" 
              onClick={() => router.push(`${pathname}/${group.id}`)}
              className="w-full text-left"
            >
              <CardHeader>
                <CardTitle>{group.courseCode}</CardTitle>
                <CardDescription>Group: {group.groupNumber}</CardDescription>
              </CardHeader>
              <CardContent>
                <p>Course ID: {group.courseID}</p>
              </CardContent>
              <CardFooter>
                <p>Group ID: {group.id}</p>
              </CardFooter>
            </button>
          </Card>
        ))
      ) : (
        <div className="text-gray-500">
          No groups found for course ID: {courseId}
        </div>
      )}
    </div>
  );
}

export default Groups;
</file>

<file path="frontend/src/app/instructor/course/page.tsx">
'use client'

import { Table, TableBody, TableCaption, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"


interface studentData{
    utorid: string;
    fname: string;
    lname: string;
    email: string;
    studentNumber: number;
}


const coursePage = () => {
    return(<div></div>)
}

export default coursePage;
</file>

<file path="frontend/src/app/instructor/instructorlogic.ts">
import { group } from "console";
import AxiosClient from "../api/axiosClient"; 

export class InstructorService{

    async getStudents(groupID: number){
        try{
            const response = await AxiosClient.get("/group/groups/", {
                params: {
                    groupID: groupID
                }
            });
            return response.data;
        } catch(error){
            console.error('Could not get the students in the specified group', error);
            return null;
        }
    }


    async getStudentFactors(courseID: number){
        try{
            const response = await AxiosClient.get("/factor/fetchFactors", {
                params: {
                    courseID: courseID,
                }
            });
            return response.data;
        } catch(error){
            console.error('Could not get the factor for the specified student', error);
            return null;

        }
    }

    async downloadCSV(courseID: number){
        try{
            const response = await AxiosClient.get("/factor/makeCSV", {
                params: {
                    courseID: courseID,
                },
                responseType: 'blob'
            });
            const blob = new Blob([response.data], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.href = url;
            link.download = `course_${courseID}_students.csv`;
            document.body.appendChild(link);
            link.click();
            
            // Cleanup
            link.remove();
            URL.revokeObjectURL(url);
            
            return { success: true };
        } catch(error){
            console.error('Could not download the csv file', error);
            return null;

        }
    }
}


export const instructorService = new InstructorService();
</file>

<file path="frontend/src/app/instructor/page.tsx">
"use client";
import { useState, useEffect } from "react";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card"
import { useAuth0 } from "@auth0/auth0-react";

import { useUser } from "@/providers/user-provider";
import { useRouter } from 'next/navigation'


interface CourseData{
    code: string;
    session: string;
    lecturer_id: number;
    id: number;
}


const fetchCourses = async (lecturer_id: number): Promise<CourseData[]> => {
    const response = await fetch("http://127.0.0.1:8080/api/courses", {
        method: "GET",
        headers: {
            'instructorID': lecturer_id.toString()
        }
    });
    const data = await response.json();
    console.log(data);
    return data;
}

const Instructor = () => {
    const { user } = useUser();
    const [courses, setCourses] = useState<CourseData[]>([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);
    


    const router = useRouter();

    useEffect(() => {
        if (!user?.id) return;
        const lecturerId = user.id;
        const loadData = async () => {
            try {
                if (!user){
                    throw new Error("Uh Oh");
                }
                const coursedata = await fetchCourses(lecturerId); // Hardcoded lecturer ID for now
                setCourses(coursedata);
                
                
            } catch (err) {
                setError(err instanceof Error ? err.message : "Failed to load courses");
            } finally {
                setLoading(false);
            }
        };

        loadData();
    }, [user?.id]);

    if (loading) return <div>Loading courses...</div>;
    if (error) return <div>Error: {error}</div>;



    return (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 p-4">
            {courses.length > 0 ? (
                courses.map((course) => (
                    
                    
                        <Card key={`${course.code}-${course.session}`} className="hover:shadow-lg transition-shadow">
                        <button type="button" onClick={() => router.push(`instructor/course/${course.id}`)}>
                        <CardHeader>
                            <CardTitle>{course.code}</CardTitle>
                            <CardDescription>{course.session} Session</CardDescription>
                        </CardHeader>
                        <CardContent>
                            <p className="text-sm text-gray-600">
                                Lecturer ID: {course.lecturer_id}
                            </p>
                        </CardContent>
                        <CardFooter>
                            <p>{course.code}</p>
                        </CardFooter>
                        </button>
                    
                    </Card>

                
                    
                ))
            ) : (
                <div className="text-gray-500">No courses found for this instructor, ID = {user?.id}</div>
            )}
        </div>
    );
    
    

}

export default Instructor;
</file>

<file path="frontend/src/app/student/group/grouplogic.ts">
export class GroupService{


    
}
</file>

<file path="frontend/src/app/student/survey/[groupID]/[courseID]/[courseCode]/page.tsx">
'use client'

import Survey from '@/components/ui/Survey';
import { surveyQuestions } from '../../../surveyQuestions';
import { studentService } from '../../../../studentlogic';
import { useEffect, useState } from 'react';
import { Student, Group, SurveyInstance } from '../../../../studentlogic';
import { useUser } from '@/providers/user-provider';

interface PageProps {
  params: Promise<{
    groupID: string;
    courseID: number;
    courseCode: string;
  }>;
}

export default function SurveyPage({ params } : PageProps) {
  const [students, setStudents] = useState<Student[]>([]);
  const [isloading, setIsLoading] = useState<boolean>(true);
  const [studentNum, setStudentNum] = useState<number>(0);
  const [resolvedParams, setResolvedParams] = useState<{
    groupID: string;
    courseID: number;
    courseCode: string;
  } | null>(null);
  const { user, loading } = useUser();
  
  // Resolve params in useEffect since this is a client component
  useEffect(() => {
    const resolveParams = async () => {
      const resolved = await params;
      setResolvedParams(resolved);
    };
    resolveParams();
  }, [params]);

  useEffect(() => {
    if (!resolvedParams) return;
    
    const getStudentsInGroup = async () => {
      const data: Student[] = await studentService.getStudentsInGroup(parseInt(resolvedParams.groupID));
      setStudents(data || []);
    };

    getStudentsInGroup();
  }, [resolvedParams]);

  useEffect(() => {
    const getStudentID = async () => {
      if (!user?.email) {
        console.log('User email not available yet');
        return;
      }

      try {
        console.log('Fetching student ID for email:', user.email);
        const studentID: number = await studentService.getStudentID(user.email);
        console.log('Student ID retrieved:', studentID);
        setStudentNum(studentID);
      } catch (error) {
        console.error('Failed to fetch student ID:', error);
      }
    };
    getStudentID();
  }, [user?.email]);

  useEffect(() => {
    // Set loading to false when both user and students are loaded
    if (!loading && students.length >= 0) { // >= 0 to handle empty arrays
      setIsLoading(false);
    }
  }, [loading, students]);

  if (loading || isloading || !resolvedParams) {
    return (
      <main className="min-h-screen bg-gray-50 py-12">
        <div className="container mx-auto px-4">
          <div className="text-center">Loading students...</div>
        </div>
      </main>
    );
  }

  if (!user) {
    return (
      <main className="min-h-screen bg-gray-50 py-12">
        <div className="container mx-auto px-4">
          <div className="text-center text-gray-600">
            Please log in to access the survey.
          </div>
        </div>
      </main>
    );
  }

  if (students.length === 0) {
    return (
      <main className="min-h-screen bg-gray-50 py-12">
        <div className="container mx-auto px-4">
          <div className="text-center text-gray-600">
            No students found in this group.
          </div>
        </div>
      </main>
    );
  }

  return (
    <main className="min-h-screen bg-gray-50 py-12">
      <div className="container mx-auto px-4">
        <div className="mb-8">
          <h1 className="text-3xl font-bold text-gray-900 mb-2">
            Group Survey
          </h1>
          <p className="text-gray-600">
            Complete the survey for each student in the group
          </p>
        </div>
        
        <div className="space-y-8">
          <Survey 
            questions={surveyQuestions} 
            groupID={parseInt(resolvedParams.groupID)}
            studentID={studentNum}
            courseID={resolvedParams.courseID}
            courseCode={resolvedParams.courseCode}
            // studentId={student.id}
            // studentName={student.name}
          />
        </div>
      </div>
    </main>
  );
}
</file>

<file path="frontend/src/app/student/survey/surveyQuestions.ts">
export interface Question {
  id: string;
  text: string;
  subtext: string;
}

export const surveyQuestions: Question[] = [
  {
    id: 'q1',
    text: 'Contribution to the Team Work.',
    subtext: 'Consistently completed the share of the team’s tasks on time. Took initiative to help the team achieve its goals. Made meaningful contributions to team discussions and planning.'
    
  },
  {
    id: 'q2',
    text: 'Interacting with Teammates',
    subtext: 'Listened respectfully to others’ ideas and perspectives. Communicated clearly and effectively with team members. Helped create a positive and inclusive team atmosphere.'
  },
  {
    id: 'q3',
    text: 'Keeping the Team on Track',
    subtext: 'Listened respectfully to others’ ideas and perspectives. Communicated clearly and effectively with team members. Helped create a positive and inclusive team atmosphere.'
  },
  {
    id: 'q4',
    text: 'Expecting Quality',
    subtext: 'Helped the team stay focused on goals and deadlines. Reminded others of responsibilities when needed. Contributed to setting and maintaining a clear plan of action.'
  }
];
</file>

<file path="frontend/src/components/auth-buttons.tsx">
// src/components/auth-buttons.tsx
'use client';
import { useAuth0 } from '@auth0/auth0-react';

export default function AuthButtons() {
  const { loginWithRedirect, logout, isAuthenticated, isLoading } = useAuth0();

  if (isLoading) return <div>Loading...</div>;

  return isAuthenticated ? (
    <button onClick={() => logout({ logoutParams: { returnTo: window.location.origin }})}>
      Logout
    </button>
  ) : (
    <button onClick={() => loginWithRedirect()}>Login</button>
  );
}
</file>

<file path="frontend/src/components/ui/ExportCSV.tsx">
'use client'
import { Student } from "@/app/student/studentlogic";
import { instructorService } from "@/app/instructor/instructorlogic";
import { StudentFactors } from "./Dashboard";
import { Button } from "./button";
import { useState, useEffect } from "react";

interface Props {
  courseID: number;
}

const ExportCSV = ({ courseID }: Props) => {
    const [isLoading, setIsLoading] = useState(false);

    const handleExport = async () => {
        setIsLoading(true);
        try {
            await instructorService.downloadCSV(courseID);
            // Success! File should be downloaded
        } catch(error) {
            console.error("Failed to download CSV:", error);
            alert("Failed to download CSV. Please try again.");
        } finally {
            setIsLoading(false);
        }
    }

    return (
        <Button onClick={handleExport} disabled={isLoading}>
            {isLoading ? "Downloading..." : "Download CSV"}
        </Button>
    )
}

export default ExportCSV;
</file>

<file path="frontend/src/providers/user-provider.tsx">
import React, { createContext, useContext, useEffect, useState, ReactNode } from "react";
import { useAuth0 } from "@auth0/auth0-react";

interface User {
  id: number;
  name: string;
  email: string;
  auth0_id?: string;
  role: string;
}

interface UserContextType {
  user: User | null;
  loading: boolean;
  error: string | null;
}

const UserContext = createContext<UserContextType>({
  user: null,
  loading: true,
  error: null,
});

export const UserProvider = ({ children }: { children: ReactNode }) => {
  const { user: auth0User, isAuthenticated, getAccessTokenSilently } = useAuth0();
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const syncAndLoadUser = async () => {
      console.log("Starting user sync process...");
      console.log(`Auth0 auth status: ${isAuthenticated}`);
      console.log(`Auth0 user:`, auth0User);
      
      if (!isAuthenticated || !auth0User) {
        console.log("User not authenticated, skipping sync");
        setUser(null);
        setLoading(false);
        return;
      }

      try {
        console.log("Getting access token...");
        const token = await getAccessTokenSilently();
        console.log("Access token received");

        // 1. Sync user info to backend
        console.log("Syncing user with backend...");
        const syncPayload = {
          sub: auth0User.sub,
          email: auth0User.email,
          name: auth0User.name || "", // Handle potential undefined name
        };
        
        console.log("Sync payload:", syncPayload);
        const syncResponse = await fetch('http://127.0.0.1:8080/users', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`,
          },
          body: JSON.stringify(syncPayload),
        });

        console.log("Sync response status:", syncResponse.status);
        
        if (!syncResponse.ok) {
          const errorText = await syncResponse.text();
          console.error("Sync error response:", errorText);
          throw new Error(`Failed to sync user: ${syncResponse.status} - ${errorText}`);
        }

        const syncData = await syncResponse.json();
        console.log("Sync successful, user data:", syncData);

        // 2. Fetch full user profile from backend
        console.log(`Fetching user profile for auth0 ID: ${auth0User.sub}`);
        const profileResponse = await fetch(
          `http://127.0.0.1:8080/users/by-auth0/${auth0User.sub}`,
          {
            headers: { Authorization: `Bearer ${token}` }
          }
        );

        console.log("Profile response status:", profileResponse.status);
        
        if (!profileResponse.ok) {
          const errorText = await profileResponse.text();
          console.error("Profile error response:", errorText);
          throw new Error(`Failed to fetch user profile: ${profileResponse.status} - ${errorText}`);
        }

        const userData = await profileResponse.json();
        console.log("User profile data:", userData);
        
        // Verify we have an ID
        if (!userData.id) {
          console.error("User ID is missing in response:", userData);
          throw new Error("User ID is missing in backend response");
        }

        setUser({
          id: userData.id,
          name: userData.name,
          email: userData.email,
          auth0_id: userData.auth0_sub || auth0User.sub,
          role: userData.role || 'student'
        });
      } catch (err) {
        console.error("User sync error:", err);
        setError(err instanceof Error ? err.message : "Unknown error");
      } finally {
        setLoading(false);
      }
    };

    syncAndLoadUser();
  }, [isAuthenticated, auth0User, getAccessTokenSilently]);

  return (
    <UserContext.Provider value={{ user, loading, error }}>
      {children}
    </UserContext.Provider>
  );
};

export const useUser = () => useContext(UserContext);
</file>

<file path="backend/.env">
AUTH0_DOMAIN = dev-4m08esq3iy51y7tm.us.auth0.com
AUTH0_API_AUDIENCE = https://peerassessment.com
AUTH0_ISSUER = https://dev-4m08esq3iy51y7tm.us.auth0.com/
AUTH0_ALGORITHMS = RS256
DATABASE_URL="postgresql://shawn:051671Dashui!@localhost:5432/peer"
JWT_SECRET_KEY="14d4c1e211aadcb0986bc4de0b79c7e966b0c2945878cbeae2d04cebb6e99e64"
</file>

<file path="backend/create_tables.py">
from models import Base, engine, StudentCourse, Group


def drop_specific_table():
    # Drop ONLY the Course table
    Group.__table__.drop(bind=engine)
    print(f"Dropped table: {StudentCourse.__tablename__}")


def create_tables():
   
    
    # Create new tables with corrected schema
    Base.metadata.create_all(bind=engine)
    print("Tables created successfully!")

if __name__ == "__main__":
    #drop_specific_table()
    create_tables()
</file>

<file path="backend/routers/api.py">
from fastapi import APIRouter, Depends, HTTPException, File, UploadFile, Form, Body, Request, Header, Query
from models import SessionLocal, User, Course, Group, Student, StudentGroup, StudentCourse
from io import BytesIO
from sqlalchemy.orm import Session
from sqlalchemy.exc import IntegrityError

from starlette.concurrency import run_in_threadpool
import pandas as pd
from schemas import StudentCreate

router = APIRouter();



def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


@router.get("/verifyemail")
async def verifyEmail(email: str = Query(...), db: Session = Depends(get_db)):
    allowed_email = db.query(Student).filter(Student.email == email).first();
    if not allowed_email:
        raise HTTPException(status_code=400, detail="Email not authorized")
    return {"allowed": True}

@router.get("/courses")
async def getCourses(request: Request,  db: Session = Depends(get_db)):
    instructor_id = request.headers.get("instructorID")
    courses = courses = db.query(Course).filter(Course.lecturer_id == instructor_id).all()
    return courses;


@router.post("/csv", response_model=StudentCreate)
async def saveCSV(
    file: UploadFile = File(..., description="CSV file containing student data"),
    courseID: int = Header(..., alias="cid", description="Course ID"),
    coursecode: str = Header(..., alias="coursecode", description="Course code"),
    db: Session = Depends(get_db)
):
    contents = await file.read()
    file_stream = BytesIO(contents)
    df = await run_in_threadpool(pd.read_csv, file_stream)
    df = df.astype(object).where(pd.notnull(df), None)

    required_columns = ["ID", "Email", "First Name", "Last Name", "UTORid", "Group Number", "Student Number"]
    missing = [col for col in required_columns if col not in df.columns]
    if missing:
        raise HTTPException(
            status_code=400,
            detail=f"Missing required columns: {', '.join(missing)}"
        )
    
    created_count = 0
    try:
        # Pre-cache groups to minimize database queries
        group_cache = {}
        
        for i in range(len(df.index)):
            # 1. Create student if not exists
            student_data = {
                "id": df["ID"][i],
                "email": df["Email"][i],
                "name": f"{df['First Name'][i]} {df['Last Name'][i]}",
                "student_id": df["Student Number"][i],
                "utorid": df["UTORid"][i],
                "firstname": df["First Name"][i],
                "lastname": df["Last Name"][i]
            }
            
            student = db.query(Student).filter_by(id=student_data["id"]).first()
            if not student:
                student = Student(**student_data)
                db.add(student)
                db.flush()  # Assign ID without committing transaction
            else:
                # Update existing student if needed
                for key, value in student_data.items():
                    setattr(student, key, value)

            # 2. Create enrollment
            enrollment = db.query(StudentCourse).filter_by(
                student_id=student.id,  # Use student.id NOT student.student_id
                course_id=courseID
            ).first()
            
            if not enrollment:
                enrollment = StudentCourse(
                    student_id=student.id,  # Correct foreign key reference
                    course_id=courseID
                )
                db.add(enrollment)

            # 3. Find or create group
            group_key = (coursecode, df["Group Number"][i], courseID)
            if group_key in group_cache:
                group = group_cache[group_key]
            else:
                group = db.query(Group).filter_by(
                    courseCode=coursecode,
                    groupNumber=df["Group Number"][i],
                    courseID=courseID
                ).first()
                
                if not group:
                    group = Group(
                        courseCode=coursecode,
                        groupNumber=df["Group Number"][i],
                        courseID=courseID
                    )
                    db.add(group)
                    db.flush()  # Generate group ID without commit
                
                group_cache[group_key] = group

            # 4. Create student-group association
            student_group = db.query(StudentGroup).filter_by(
                student_id=student.id,
                group_id=group.id
            ).first()
            
            if not student_group:
                student_group = StudentGroup(
                    student_id=student.id,
                    group_id=group.id
                )
                db.add(student_group)
            
            created_count += 1

        db.commit()
    except IntegrityError as e:
        db.rollback()
        raise HTTPException(
            status_code=409,
            detail=f"Database integrity error: {str(e)}"
        )
    except (KeyError, TypeError) as e:
        db.rollback()
        raise HTTPException(
            status_code=400,
            detail=f"Invalid row data: {str(e)}"
        )
    except Exception as e:
        db.rollback()
        raise HTTPException(
            status_code=500,
            detail=f"Error processing CSV: {str(e)}"
        )
        
    return {
        "status": "success",
        "filename": file.filename,
        "created_count": created_count,
        "total_rows": len(df)
    }
</file>

<file path="backend/routers/courses.py">
from fastapi import APIRouter, Depends, HTTPException, File, UploadFile, Form, Body, Request, Header, Query
from models import SessionLocal, User, Course, Group, Student, StudentGroup, StudentCourse
from io import BytesIO
from sqlalchemy.orm import Session
from sqlalchemy.exc import IntegrityError

from starlette.concurrency import run_in_threadpool
import pandas as pd
from schemas import StudentCreate
from models import get_db

router = APIRouter();


async def get_students_in_course_helper(courseID: str = Query(...), db: Session = Depends(get_db)):
    #Get student ids 
    student_course_rows = db.query(StudentCourse).filter(StudentCourse.course_id == courseID).all()
    student_ids = [row.student_id for row in student_course_rows]
    students = db.query(Student).filter(Student.id.in_(student_ids)).all()
    return students
#get students enrolled in this course
@router.get("/course/students")
async def get_students_in_course(courseID: str = Query(...), db: Session = Depends(get_db)):
    student_course_rows = db.query(StudentCourse).filter(StudentCourse.course_id == courseID).all()
    student_ids = [row.student_id for row in student_course_rows]
    students = db.query(Student).filter(Student.id.in_(student_ids)).all()
    return students
</file>

<file path="backend/routers/users.py">
# Endpoint to create user in PostgreSQL
from fastapi import APIRouter, Depends, HTTPException, Body
from models import SessionLocal, User, Course, Group, Student, StudentGroup, StudentCourse, get_db
from sqlalchemy.orm import Session


router = APIRouter(prefix="/users", tags=["users"])


@router.get("/studentid")
async def getStudentID(email: str, db: Session = Depends(get_db)):
    #get based on the same email
    student = db.query(Student).filter(Student.email == email).first()
    return student.id

@router.post("")
async def create_user(payload: dict = Body(...), db: Session = Depends(get_db)):
    auth0_id = payload["sub"]
    
    # Check if user exists
    user = db.query(User).filter(User.auth0_id == auth0_id).first()
    if user:
        return user
    
    # Create new user
    new_user = User(
        auth0_id=auth0_id, 
        email=payload["email"],
        name=payload.get("name", "")
    )
    db.add(new_user)
    db.commit()
    db.refresh(new_user)
    return new_user

@router.get("/by-auth0/{auth0_sub}")
async def getUserByAuth0(auth0_sub: str, db: Session = Depends(get_db)):
    user = db.query(User).filter(User.auth0_id == auth0_sub).first()
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    
    return {
        "id": user.id,
        "name": user.name,
        "email": user.email,
        "auth0_sub": user.auth0_id,
        "role": user.role
    }
</file>

<file path="frontend/src/app/instructor/course/[courseID]/page.tsx">
import Dashboard from '@/components/ui/Dashboard';
import CoursePageClient from './CoursePageClient';
import Groups from './GroupClient';

interface CoursePageProps {
  params: Promise<{
    courseID: string;
  }>;
}

const CoursePage = async ({ params }: CoursePageProps) => {
  // Await the params before using them
  const { courseID } = await params;
  
  // Convert to number if needed
  const numericCourseId = parseInt(courseID);

  return (
    <div>
      <Groups courseId={numericCourseId}/>
      <CoursePageClient courseId={numericCourseId} />
      <Dashboard courseID={numericCourseId}/>
    </div>
  );
};

export default CoursePage;
</file>

<file path="frontend/src/app/layout.tsx">
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import { SidebarProvider } from "@/components/ui/sidebar"
import './globals.css';
import AuthProvider from '@/providers/auth-provider';


const geist = Geist({ subsets: ['latin'] });
const geistMono = Geist_Mono({ subsets: ['latin'] });

export const metadata: Metadata = {
  title: "Your App Name",
  description: "Your app description",
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <body className={`${geist.className} ${geistMono.className}`}>
        <AuthProvider>
          <SidebarProvider>
            {children}
          </SidebarProvider>
        </AuthProvider>
        
      </body>
    </html>
  )
}
</file>

<file path="frontend/src/app/student/studentlogic.ts">
import AxiosClient from "../api/axiosClient"; 

export interface Group{
    id: number;
    courseCode: string;
    groupNumber: number;
    courseID: number;
}

export interface Student{
    id: number;
    name: string;
    email: string;
    fname: string;
    lname: string;
}

export interface SurveyInstance{
    evaluator_id: number;
    question_id: string;
    evaluatee_id: number;
    group_id: number;
    course_id: number;
    course_code: string;
    answer: number;
}

export class StudentService{


    async getGroups(studentID: number): Promise<Group[] | null>{

        try {
            const response = await AxiosClient.get('group/usersgroups', {
                params: { studentID: studentID }
            });
            return response.data;
        } catch (error) {
            console.error('Error fetching groups:', error);
            return null;
        }
    }

    async getStudentsInGroup(groupID: number){
        try {
            const response = await AxiosClient.get('group/groups/', {
                params: { groupID: groupID }
            });
            return response.data;
        } catch (error) {
            console.error('Error fetching students in group:', error);
            return null;
        }
    }

    async getStudentID(email: string){
        try {
            const response = await AxiosClient.get('users/studentid/' , {
                params: { email: email }
            });
            return response.data
        } catch(error){
            console.error('Could not get the student ID from the specified email', error);
            return null;
        }
    }

    async postSurveyInstance(payload: SurveyInstance){
        try {
            const response = await AxiosClient.post('group/postsurvey/', payload);
            return response.data;
        } catch(error){
            console.error('Error posting survey:', error);
            throw error;
        }
    }
}

export const studentService = new StudentService();
</file>

<file path="frontend/src/components/app-sidebar.tsx">
"use client";

import { Calendar, Home, Inbox, Search, Settings } from "lucide-react"
import FileDrop from "./file-drop"
import LoginButton from "./loginbutton";
import LogoutButton from "./logoutbutton";
import {
  Sidebar,
  SidebarContent,
  SidebarGroup,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarMenu,
  SidebarMenuButton,
  SidebarMenuItem,
} from "@/components/ui/sidebar"

// Menu items.
const items = [
  {
    title: "Home",
    url: "/instructor",
    icon: Home,
  },
  // {
  //   title: "Import CSV",
  //   url: "#",
  //   icon: Inbox,
  // },
  
]

export function AppSidebar() {
  return (
    <Sidebar>
      <SidebarContent>
        <SidebarGroup>
          <SidebarGroupLabel>Peer Assessment</SidebarGroupLabel>
          <SidebarGroupLabel>Welcome back</SidebarGroupLabel>
          <SidebarGroupContent>
            <SidebarMenu>
              {items.map((item) => (
                <SidebarMenuItem key={item.title}>
                  <SidebarMenuButton asChild>
                    <a href={item.url}>
                      <item.icon />
                      <span>{item.title}</span>
                    </a>
                  </SidebarMenuButton>
                </SidebarMenuItem>
              ))}
              <FileDrop/>
              <LoginButton/>
              <LogoutButton/>
            </SidebarMenu>
          </SidebarGroupContent>
        </SidebarGroup>
      </SidebarContent>
    </Sidebar>
  )
}
</file>

<file path="frontend/src/components/TableSurvey.tsx">
// 'use client'

// import { useEffect, useState } from "react";
// import { Plus, Trash2, Edit2, Save, X } from 'lucide-react';

// export interface TableSurveyProps{
    
// }


// const SurveyTable = () => {
//   const [questions, setQuestions] = useState([
//     'Communication Skills',
//     'Technical Expertise',
//     'Teamwork',
//     'Leadership Potential'
//   ]);
  
//   const [people, setPeople] = useState([
//     'John Smith',
//     'Sarah Johnson',
//     'Mike Chen'
//   ]);
  
//   const [responses, setResponses] = useState({});
//   const [editingQuestion, setEditingQuestion] = useState(null);
//   const [editingPerson, setEditingPerson] = useState(null);
//   const [newQuestionText, setNewQuestionText] = useState('');
//   const [newPersonText, setNewPersonText] = useState('');

//   const getResponseKey = (person, question) => `${person}-${question}`;

//   const handleResponseChange = (person, question, value) => {
//     const key = getResponseKey(person, question);
//     setResponses(prev => ({
//       ...prev,
//       [key]: value
//     }));
//   };

//   const addQuestion = () => {
//     const newQuestion = `Question ${questions.length + 1}`;
//     setQuestions(prev => [...prev, newQuestion]);
//   };

//   const addPerson = () => {
//     const newPerson = `Person ${people.length + 1}`;
//     setPeople(prev => [...prev, newPerson]);
//   };

//   const removeQuestion = (index) => {
//     const questionToRemove = questions[index];
//     setQuestions(prev => prev.filter((_, i) => i !== index));
//     // Clean up responses for removed question
//     setResponses(prev => {
//       const newResponses = { ...prev };
//       Object.keys(newResponses).forEach(key => {
//         if (key.endsWith(`-${questionToRemove}`)) {
//           delete newResponses[key];
//         }
//       });
//       return newResponses;
//     });
//   };

//   const removePerson = (index) => {
//     const personToRemove = people[index];
//     setPeople(prev => prev.filter((_, i) => i !== index));
//     // Clean up responses for removed person
//     setResponses(prev => {
//       const newResponses = { ...prev };
//       Object.keys(newResponses).forEach(key => {
//         if (key.startsWith(`${personToRemove}-`)) {
//           delete newResponses[key];
//         }
//       });
//       return newResponses;
//     });
//   };

//   const saveQuestionEdit = (index) => {
//     const oldQuestion = questions[index];
//     setQuestions(prev => prev.map((q, i) => i === index ? newQuestionText : q));
    
//     // Update response keys
//     if (oldQuestion !== newQuestionText) {
//       setResponses(prev => {
//         const newResponses = { ...prev };
//         Object.keys(newResponses).forEach(key => {
//           if (key.endsWith(`-${oldQuestion}`)) {
//             const person = key.split(`-${oldQuestion}`)[0];
//             const newKey = getResponseKey(person, newQuestionText);
//             newResponses[newKey] = newResponses[key];
//             delete newResponses[key];
//           }
//         });
//         return newResponses;
//       });
//     }
    
//     setEditingQuestion(null);
//     setNewQuestionText('');
//   };

//   const savePersonEdit = (index) => {
//     const oldPerson = people[index];
//     setPeople(prev => prev.map((p, i) => i === index ? newPersonText : p));
    
//     // Update response keys
//     if (oldPerson !== newPersonText) {
//       setResponses(prev => {
//         const newResponses = { ...prev };
//         Object.keys(newResponses).forEach(key => {
//           if (key.startsWith(`${oldPerson}-`)) {
//             const question = key.substring(`${oldPerson}-`.length);
//             const newKey = getResponseKey(newPersonText, question);
//             newResponses[newKey] = newResponses[key];
//             delete newResponses[key];
//           }
//         });
//         return newResponses;
//       });
//     }
    
//     setEditingPerson(null);
//     setNewPersonText('');
//   };

//   const exportData = () => {
//     const data = {
//       questions,
//       people,
//       responses
//     };
//     console.log('Survey Data:', data);
//     alert('Survey data exported to console. Check browser developer tools.');
//   };

//   return (
//     <div className="p-6 max-w-6xl mx-auto bg-white">
//       <div className="mb-6">
//         <h1 className="text-3xl font-bold text-gray-800 mb-2">Survey Evaluation Table</h1>
//         <p className="text-gray-600">Evaluate people across different criteria. Click cells to rate, edit names by clicking the edit icon.</p>
//       </div>

//       <div className="mb-4 flex gap-2">
//         <button 
//           onClick={addQuestion}
//           className="flex items-center gap-2 px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors"
//         >
//           <Plus size={16} />
//           Add Question
//         </button>
//         <button 
//           onClick={addPerson}
//           className="flex items-center gap-2 px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors"
//         >
//           <Plus size={16} />
//           Add Person
//         </button>
//         <button 
//           onClick={exportData}
//           className="flex items-center gap-2 px-4 py-2 bg-purple-500 text-white rounded-lg hover:bg-purple-600 transition-colors"
//         >
//           Export Data
//         </button>
//       </div>

//       <div className="overflow-x-auto border rounded-lg shadow-sm">
//         <table className="w-full border-collapse bg-white">
//           <thead>
//             <tr className="bg-gray-50">
//               <th className="border p-3 text-left font-semibold text-gray-700 min-w-[150px]">
//                 Person / Question
//               </th>
//               {questions.map((question, index) => (
//                 <th key={question} className="border p-3 text-center font-semibold text-gray-700 min-w-[140px]">
//                   <div className="flex items-center justify-center gap-2">
//                     {editingQuestion === index ? (
//                       <div className="flex items-center gap-1">
//                         <input
//                           type="text"
//                           value={newQuestionText}
//                           onChange={(e) => setNewQuestionText(e.target.value)}
//                           className="px-2 py-1 border rounded text-sm w-24"
//                           onKeyPress={(e) => e.key === 'Enter' && saveQuestionEdit(index)}
//                         />
//                         <button
//                           onClick={() => saveQuestionEdit(index)}
//                           className="text-green-600 hover:text-green-800"
//                         >
//                           <Save size={14} />
//                         </button>
//                         <button
//                           onClick={() => {
//                             setEditingQuestion(null);
//                             setNewQuestionText('');
//                           }}
//                           className="text-red-600 hover:text-red-800"
//                         >
//                           <X size={14} />
//                         </button>
//                       </div>
//                     ) : (
//                       <>
//                         <span className="text-sm">{question}</span>
//                         <button
//                           onClick={() => {
//                             setEditingQuestion(index);
//                             setNewQuestionText(question);
//                           }}
//                           className="text-gray-400 hover:text-gray-600"
//                         >
//                           <Edit2 size={14} />
//                         </button>
//                         {questions.length > 1 && (
//                           <button
//                             onClick={() => removeQuestion(index)}
//                             className="text-red-400 hover:text-red-600"
//                           >
//                             <Trash2 size={14} />
//                           </button>
//                         )}
//                       </>
//                     )}
//                   </div>
//                 </th>
//               ))}
//             </tr>
//           </thead>
//           <tbody>
//             {people.map((person, personIndex) => (
//               <tr key={person} className="hover:bg-gray-50">
//                 <td className="border p-3 font-medium text-gray-700 bg-gray-50">
//                   <div className="flex items-center gap-2">
//                     {editingPerson === personIndex ? (
//                       <div className="flex items-center gap-1">
//                         <input
//                           type="text"
//                           value={newPersonText}
//                           onChange={(e) => setNewPersonText(e.target.value)}
//                           className="px-2 py-1 border rounded text-sm flex-1"
//                           onKeyPress={(e) => e.key === 'Enter' && savePersonEdit(personIndex)}
//                         />
//                         <button
//                           onClick={() => savePersonEdit(personIndex)}
//                           className="text-green-600 hover:text-green-800"
//                         >
//                           <Save size={14} />
//                         </button>
//                         <button
//                           onClick={() => {
//                             setEditingPerson(null);
//                             setNewPersonText('');
//                           }}
//                           className="text-red-600 hover:text-red-800"
//                         >
//                           <X size={14} />
//                         </button>
//                       </div>
//                     ) : (
//                       <>
//                         <span>{person}</span>
//                         <button
//                           onClick={() => {
//                             setEditingPerson(personIndex);
//                             setNewPersonText(person);
//                           }}
//                           className="text-gray-400 hover:text-gray-600"
//                         >
//                           <Edit2 size={14} />
//                         </button>
//                         {people.length > 1 && (
//                           <button
//                             onClick={() => removePerson(personIndex)}
//                             className="text-red-400 hover:text-red-600"
//                           >
//                             <Trash2 size={14} />
//                           </button>
//                         )}
//                       </>
//                     )}
//                   </div>
//                 </td>
//                 {questions.map((question) => (
//                   <td key={question} className="border p-3 text-center">
//                     <select
//                       value={responses[getResponseKey(person, question)] || ''}
//                       onChange={(e) => handleResponseChange(person, question, e.target.value)}
//                       className="w-full px-2 py-1 border rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
//                     >
//                       <option value="">Select...</option>
//                       <option value="1">1 - Poor</option>
//                       <option value="2">2 - Below Average</option>
//                       <option value="3">3 - Average</option>
//                       <option value="4">4 - Good</option>
//                       <option value="5">5 - Excellent</option>
//                     </select>
//                   </td>
//                 ))}
//               </tr>
//             ))}
//           </tbody>
//         </table>
//       </div>

//       <div className="mt-4 text-sm text-gray-600">
//         <p><strong>Instructions:</strong></p>
//         <ul className="list-disc list-inside mt-1 space-y-1">
//           <li>Click the dropdown in each cell to rate a person on that criteria (1-5 scale)</li>
//           <li>Use the edit icon next to names to rename questions or people</li>
//           <li>Add new questions or people using the buttons above the table</li>
//           <li>Remove items using the trash icon (minimum 1 question and 1 person required)</li>
//           <li>Export your data to see all responses in the browser console</li>
//         </ul>
//       </div>
//     </div>
//   );
// };

// export default SurveyTable;
</file>

<file path="frontend/src/components/ui/Dashboard.tsx">
'use client'

import { useEffect, useState } from "react"
import { instructorService } from "@/app/instructor/instructorlogic";
import { useUser } from "@/providers/user-provider";
import { Student } from "@/app/student/studentlogic";
import Factortable from "./FactorTable";
import ExportCSV from "./ExportCSV";

// "student_id": 1004985643,
//             "name": "Yuening Chen",
//             "factorWithSelf": 1.0,
//             "factorWithoutSelf": 1.0

interface DashboardProps{
    courseID: number;
}

interface AdjustmentFactorTableProps {
    name: string;
    student_id: number;
    factorWithSelf: number;
    factorWithoutSelf: number;
    courseCode: string;
    groupNumber: number;
    courseID: number;
}

export interface StudentFactors{
    name: string;
    utorid: number;
    factorWithSelf: number;
    factorWithoutSelf: number;
    courseCode: string;
    groupNumber: number;
    courseID: number;
}

const Dashboard = (params: DashboardProps) => {
    const { user } = useUser();
    const [students, setStudents] = useState<Student[]>([]);
    const [studentFactors, setStudentFactors] = useState<StudentFactors[]>([]);

    useEffect(() => {
        if (!user?.id) return; 
        
        const fetchData = async () => {
            const factorData : StudentFactors[] = await instructorService.getStudentFactors(params.courseID);
            setStudentFactors(factorData);
        }
        fetchData();

    }, [user?.id, params.courseID])

    return(
        <div>
            <ExportCSV courseID={params.courseID}/>
            <Factortable data={studentFactors}/>

        </div>
    );
}

export default Dashboard;
</file>

<file path="frontend/src/components/ui/FactorTable.tsx">
'use client'
import {
  Table,
  TableBody,
  TableCaption,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table"
import { StudentFactors } from "./Dashboard"

interface Props {
  data: StudentFactors[];
}


const FactorTable = (params: Props) => {
    // Handle empty or undefined data
    if (!params.data || params.data.length === 0) {
        return (
            <div className="w-full max-w-6xl mx-auto p-6">
                <h2 className="text-2xl font-bold mb-4 text-gray-900">Student Adjustment Factors</h2>
                <p className="text-gray-500">No student data available.</p>
            </div>
        );
    }

    return (
        <div className="w-full max-w-6xl mx-auto p-6">
            <h2 className="text-2xl font-bold mb-4 text-gray-900">Student Adjustment Factors</h2>
            <Table>
                <TableCaption>
                    A list of students and their adjustment factors (AFW: Adjustment Factor With Self, AFWO: Adjustment Factor Without Self).
                </TableCaption>
                <TableHeader>
                    <TableRow>
                        <TableHead className="w-48">Student Name</TableHead>
                        <TableHead className="w-32">Course</TableHead>
                        <TableHead className="w-32">Student ID</TableHead>
                        <TableHead className="w-32">Group Number</TableHead>
                        <TableHead className="w-32">Course ID</TableHead>
                        <TableHead className="text-right w-24">AFW</TableHead>
                        <TableHead className="text-right w-24">AFWO</TableHead>
                    </TableRow>
                </TableHeader>
                <TableBody>
                    {params.data.map((student, index) => {
                        // Defensive checks for properties
                        const studentName = student?.name ?? 'N/A';
                        const course = student?.courseCode ?? 'N/A';
                        const studentId = student.utorid ?? 'N/A';
                        const groupNumber = student?.groupNumber ?? 'N/A';
                        const courseId = student?.courseID ?? 'N/A';
                        const afw = student?.factorWithSelf;
                        const afwo = student?.factorWithoutSelf;
                        
                        return (
                            <TableRow key={studentId || index}>
                                <TableCell className="font-medium">
                                    {studentName}
                                </TableCell>
                                <TableCell>
                                    {course}
                                </TableCell>
                                <TableCell>
                                    {studentId}
                                </TableCell>
                                <TableCell>
                                    {groupNumber}
                                </TableCell>
                                <TableCell>
                                    {courseId}
                                </TableCell>
                                <TableCell className="text-right">
                                    {typeof afw === 'number' ? afw.toFixed(3) : 'N/A'}
                                </TableCell>
                                <TableCell className="text-right">
                                    {typeof afwo === 'number' ? afwo.toFixed(3) : 'N/A'}
                                </TableCell>
                            </TableRow>
                        );
                    })}
                </TableBody>
            </Table>
        </div>
    );
}

export default FactorTable;
</file>

<file path="frontend/src/app/page.tsx">
'use client';
import { useAuth0 } from '@auth0/auth0-react';
import { useRouter } from 'next/navigation';
import LoginButton from '@/components/loginbutton';
import { useEffect } from 'react';
export default function Home() {
  const { isAuthenticated } = useAuth0();
  const router = useRouter();

  
  if (isAuthenticated) {
    router.push('/authRedirect');
  }

  

  return (
    <div className="min-h-screen flex items-center justify-center">
      <div className="text-center">
        <h1 className="text-3xl font-bold mb-6">Peer Assessment System</h1>
        <LoginButton/>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/app/instructor/course/[courseID]/[groupID]/page.tsx">
import GroupStudentClient from './GroupStudentClient';
import Dashboard from '@/components/ui/Dashboard';

// export default function CoursePage({
//   params,
// }: {
//   params: {
//     groupID: string;
//     courseID: string;
//   };
// }) {
//   return (
//     <div>
//       <GroupStudentClient groupID={parseInt(params.groupID)} />
//       <Dashboard courseID={parseInt(params.courseID)} />
//     </div>
//   );
// }



interface CoursePageProps {
  params: Promise<{
    courseID: string;
    groupID: string;
  }>;
}

export default async function CoursePage({ params }: CoursePageProps) {
  // Await the params before using them
  const { courseID, groupID } = await params;

  return (
    <div>
      <GroupStudentClient groupID={parseInt(groupID)} />
      <Dashboard courseID={parseInt(courseID)} />
    </div>
  );
}
</file>

<file path="frontend/src/app/student/page.tsx">
"use client";

import {
  Card,
  CardAction,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card"

import { StudentService, Group } from "./studentlogic";
import { useRouter } from "next/navigation";
import { useEffect, useState } from "react";
import { useAuth0 } from "@auth0/auth0-react";
import { group } from "console";

const Student = () => {
  const { user, isAuthenticated, isLoading } = useAuth0();
  const router = useRouter();
  const [ studentServiceInstance ] = useState(() => new StudentService());

  const [groups, setGroups] = useState<Group[]>([]);

  //get groups and set them
  useEffect(()=> {
    const fetchGroups = async () => {
      if (isAuthenticated && user?.sub){
        const response = await studentServiceInstance.getGroups(123456);
        
        if (response){
          setGroups(response);
        } 
      
      }
    };
    if (isAuthenticated && user?.sub) {
      fetchGroups();
    }

    
    

  }, [isAuthenticated, user?.sub, studentServiceInstance])
  return (
    <div className="p-4">
      <h2 className="text-lg font-semibold mb-6">
        You have the following surveys to complete:
      </h2>

       <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 p-4">
            {groups.length > 0 ? (
                groups.map((group) => (
                    
                    
                        <Card key={`${group.id}`} className="hover:shadow-lg transition-shadow">
                        <button type="button" onClick={() => router.push(`student/survey/${group.id}/${group.courseID}/${group.courseCode}`)}>
                        <CardHeader>
                            <CardTitle>{group.courseCode}</CardTitle>
                            <CardDescription>Group {group.groupNumber} </CardDescription>
                        </CardHeader>
                        <CardContent>
                            <p className="text-sm text-gray-600">
                                Group ID: {group.id}
                            </p>
                        </CardContent>
                        <CardFooter>
                            <p>Begin Survey</p>
                        </CardFooter>
                        </button>
                    
                    </Card>

                
                    
                ))
            ) : (
                <div className="text-gray-500">No groups found for this student, ID = {user?.id}</div>
            )}
        </div>

      

      
      
      {/* <div className="flex flex-col md:flex-row gap-6 md:gap-8 justify-between p-4">
        <button type="button" onClick={() => router.push(`student/course/`)}>
        <Card className="flex-1">
          <CardHeader>
            <CardTitle>STAC67</CardTitle>
            <CardDescription>Group 2</CardDescription>
          </CardHeader>
          <CardContent>
            <p>Regression Analysis</p>
          </CardContent>
        </Card>
        </button>


        <button type="button" onClick={() => router.push(``)}>
        <Card className="flex-1">
          <CardHeader>
            <CardTitle>CSCC01</CardTitle>
            <CardDescription>Group: 4</CardDescription>
          </CardHeader>
          <CardContent>
            <p>Intro to Software Engineering</p>
          </CardContent>
        </Card>
        </button>

        <button type="button" onClick={() => router.push(``)}>
        <Card className="flex-1">
          <CardHeader>
            <CardTitle>CSCC01</CardTitle>
            <CardDescription>Group: 4</CardDescription>
          </CardHeader>
          <CardContent>
            <p>Intro to Software Engineering</p>
          </CardContent>
        </Card>
        </button>

      </div> */}
    </div>
  );
};

export default Student;
</file>

<file path="frontend/src/components/ui/Survey.tsx">
'use client';
import { useEffect, useState, useCallback, useMemo } from 'react';
import { Student, SurveyInstance, studentService } from '@/app/student/studentlogic';
import { useAuth0 } from '@auth0/auth0-react';
import { useUser } from '@/providers/user-provider';

interface Question {
  id: string;
  text: string;
  subtext: string;
}

interface SurveyAnswer {
  studentId: number;
  questionId: string;
  value: number;
}

interface SurveyProps {
  questions: Question[];
  groupID: number;
  courseID: number;
  studentID: number;
  courseCode: string;
}

// Separate component for option buttons
const OptionButton = ({ 
  value, 
  selected, 
  onClick 
}: { 
  value: number; 
  selected: boolean; 
  onClick: () => void; 
}) => (
  <button
    type="button"
    onClick={onClick}
    className={`w-8 h-8 rounded-full flex items-center justify-center transition-all text-sm
      ${selected 
        ? 'bg-blue-600 text-white transform scale-110' 
        : 'bg-gray-100 hover:bg-gray-200 text-gray-800'
      }`}
    aria-pressed={selected}
  >
    {value}
  </button>
);

// Table cell component for student-question intersection
const SurveyCell = ({
  student,
  questionId,
  selectedValue,
  onSelect,
  showError,
  isAnswered
}: {
  student: Student;
  questionId: string;
  selectedValue?: number;
  onSelect: (value: number) => void;
  showError: boolean;
  isAnswered: boolean;
}) => {
  const isMissing = !isAnswered && showError;

  return (
    <td 
      className={`p-3 border-r border-gray-200 text-center transition-all ${
        isMissing 
          ? 'bg-red-50 border-red-200 missing-answer' 
          : 'bg-white hover:bg-gray-50'
      }`}
    >
      <div className="flex justify-center gap-1">
        {[1, 2, 3, 4, 5].map((value) => (
          <OptionButton 
            key={value}
            value={value}
            selected={selectedValue === value}
            onClick={() => onSelect(value)}
          />
        ))}
      </div>
      {isMissing && (
        <div className="text-red-600 text-xs mt-1">Required</div>
      )}
    </td>
  );
};

// Custom hook for survey logic (unchanged)
const useSurveyLogic = (groupID: number, questions: Question[]) => {
  const [students, setStudents] = useState<Student[]>([]);
  const [answers, setAnswers] = useState<Map<string, number>>(new Map());
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const loadStudents = async () => {
      try {
        const data = await studentService.getStudentsInGroup(groupID);
        setStudents(data || []);
      } catch (error) {
        console.error('Failed to load students:', error);
        setStudents([]);
      } finally {
        setLoading(false);
      }
    };
    loadStudents();
  }, [groupID]);

  const setAnswer = useCallback((studentId: number, questionId: string, value: number) => {
    const key = `${studentId}-${questionId}`;
    setAnswers(prev => new Map(prev).set(key, value));
  }, []);

  const getAnswer = useCallback((studentId: number, questionId: string): number | undefined => {
    return answers.get(`${studentId}-${questionId}`);
  }, [answers]);

  const isAnswered = useCallback((studentId: number, questionId: string): boolean => {
    return answers.has(`${studentId}-${questionId}`);
  }, [answers]);

  // Memoized calculations
  const totalRequired = useMemo(() => 
    students.length * questions.length, 
    [students.length, questions.length]
  );

  const currentAnswers = answers.size;
  const isComplete = currentAnswers === totalRequired;

  const missingAnswers = useMemo(() => {
    const missing: Array<{ studentName: string; questionText: string }> = [];
    
    students.forEach(student => {
      questions.forEach(question => {
        if (!isAnswered(student.id, question.id)) {
          missing.push({
            studentName: student.name,
            questionText: question.text
          });
        }
      });
    });
    
    return missing;
  }, [students, questions, isAnswered]);

  return {
    students,
    answers,
    loading,
    setAnswer,
    getAnswer,
    isAnswered,
    totalRequired,
    currentAnswers,
    isComplete,
    missingAnswers
  };
};

// Main Survey Component
const Survey = ({ questions, groupID, courseID, studentID, courseCode }: SurveyProps) => {
  //const { user } = useAuth0();
  const { user } = useUser();
  
  const {
    students,
    loading,
    setAnswer,
    getAnswer,
    isAnswered,
    totalRequired,
    currentAnswers,
    isComplete,
    missingAnswers
  } = useSurveyLogic(groupID, questions);

  const [submitted, setSubmitted] = useState(false);
  const [showError, setShowError] = useState(false);
  const [submitting, setSubmitting] = useState(false);

  const handleSelect = useCallback((studentId: number, questionId: string, value: number) => {
    setAnswer(studentId, questionId, value);
    if (showError) {
      setShowError(false);
    }
  }, [setAnswer, showError]);
  
  const createSurveyPayloads = useCallback((): SurveyInstance[] => {
    const payloads: SurveyInstance[] = [];
    const evaluatorId = user?.id ?? 313785;
    
    students.forEach(student => {
      questions.forEach(question => {
        const answer = getAnswer(student.id, question.id);
        
        if (answer !== undefined) {
          payloads.push({
            evaluator_id: studentID,
            question_id: question.id,
            answer: answer,
            evaluatee_id: student.id,
            group_id: groupID,
            course_id: courseID,
            course_code: courseCode
          });
        }
      });
    });
    console.log(payloads);
    return payloads;
  }, [students, questions, getAnswer, groupID, courseID]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!isComplete) {
      setShowError(true);
      const firstMissing = document.querySelector('.missing-answer');
      firstMissing?.scrollIntoView({ behavior: 'smooth', block: 'center' });
      return;
    }

    setSubmitting(true);
    
    try {
      const payloads = createSurveyPayloads();
      console.log('Survey payloads:', payloads);
      
      // Submit all responses
      for (const payload of payloads) {
        console.log('Submitting:', payload);
        await studentService.postSurveyInstance(payload);
      }
      
      setSubmitted(true);
    } catch (error) {
      console.error('Error submitting survey:', error);
      setShowError(true);
    } finally {
      setSubmitting(false);
    }
  };

  if (loading) {
    return (
      <div className="p-4 text-center">
        <div className="animate-pulse">Loading students...</div>
      </div>
    );
  }

  if (submitted) {
    return (
      <div className="p-4 bg-green-100 text-green-800 rounded-lg text-center">
        <h3 className="text-lg font-semibold mb-2">Thank you for completing the survey!</h3>
        <p>All responses have been recorded successfully.</p>
        <div className="mt-4 text-sm">
          <p>Submitted {currentAnswers} responses for {students.length} students across {questions.length} questions.</p>
        </div>
      </div>
    );
  }

  return (
    <form onSubmit={handleSubmit} className="max-w-full mx-auto p-6 bg-white rounded-lg shadow-md">
      <h2 className="text-2xl font-bold mb-6 text-center">Survey</h2>
      
      {/* Progress indicator */}
      <div className="mb-6">
        <div className="flex justify-between text-sm mb-2">
          <span>Progress</span>
          <span>{currentAnswers}/{totalRequired} completed</span>
        </div>
        <div className="w-full bg-gray-200 rounded-full h-2">
          <div 
            className="bg-blue-600 h-2 rounded-full transition-all duration-300"
            style={{ width: `${(currentAnswers / totalRequired) * 100}%` }}
          />
        </div>
      </div>

      {/* Error message */}
      {showError && (
        <div className="mb-6 p-4 bg-red-100 border border-red-400 text-red-700 rounded">
          <h4 className="font-semibold mb-2">Please complete all questions:</h4>
          <ul className="text-sm space-y-1">
            {missingAnswers.slice(0, 5).map((missing, index) => (
              <li key={index}>
                • {missing.studentName} - {missing.questionText}
              </li>
            ))}
            {missingAnswers.length > 5 && (
              <li className="text-gray-600">
                ... and {missingAnswers.length - 5} more
              </li>
            )}
          </ul>
        </div>
      )}

      {/* Rating scale legend */}
      <div className="mb-6 p-4 bg-gray-50 rounded-lg">
        <h3 className="text-sm font-semibold mb-2">Rating Scale:</h3>
        <div className="flex justify-center gap-6 text-sm">
          <span>1 - Poor</span>
          <span>2 - Fair</span>
          <span>3 - Good</span>
          <span>4 - Very Good</span>
          <span>5 - Excellent</span>
        </div>
      </div>
      
      {/* Survey Table */}
      <div className="overflow-x-auto">
        <table className="w-full border-collapse border border-gray-300 bg-white">
          <thead>
            <tr className="bg-gray-100">
              <th className="border border-gray-300 p-3 text-left font-semibold sticky left-0 bg-gray-100 z-10">
                Student
              </th>
              {questions.map((question) => (
                <th 
                  key={question.id} 
                  className="border border-gray-300 p-3 text-center font-semibold min-w-[200px]"
                >
                  <div className="mb-2">{question.text}</div>
                  <div className="text-xs text-gray-600 font-normal">
                    {question.subtext}
                  </div>
                </th>
              ))}
            </tr>
          </thead>
          <tbody>
            {students.map((student) => (
              <tr key={student.id} className="hover:bg-gray-50">
                <td className="border border-gray-300 p-3 font-medium sticky left-0 bg-white z-10">
                  <div className="flex items-center justify-between">
                    <span>{student.name}</span>
                    <div className="flex gap-1">
                      {questions.map((question) => (
                        <div
                          key={question.id}
                          className={`w-2 h-2 rounded-full ${
                            isAnswered(student.id, question.id)
                              ? 'bg-green-500'
                              : 'bg-gray-300'
                          }`}
                          title={`${question.text}: ${
                            isAnswered(student.id, question.id) ? 'Answered' : 'Not answered'
                          }`}
                        />
                      ))}
                    </div>
                  </div>
                </td>
                {questions.map((question) => (
                  <SurveyCell
                    key={question.id}
                    student={student}
                    questionId={question.id}
                    selectedValue={getAnswer(student.id, question.id)}
                    onSelect={(value) => handleSelect(student.id, question.id, value)}
                    showError={showError}
                    isAnswered={isAnswered(student.id, question.id)}
                  />
                ))}
              </tr>
            ))}
          </tbody>
        </table>
      </div>

      <div className="mt-8">
        <button 
          type="submit" 
          className={`w-full py-3 rounded-lg transition font-semibold ${
            isComplete && !submitting
              ? 'bg-blue-600 text-white hover:bg-blue-700' 
              : 'bg-gray-300 text-gray-500 cursor-not-allowed'
          }`}
          disabled={!isComplete || submitting}
        >
          {submitting 
            ? 'Submitting...'
            : isComplete 
              ? 'Submit Survey' 
              : `Complete All Questions (${currentAnswers}/${totalRequired})`
          }
        </button>
        
        {!isComplete && (
          <p className="text-center text-sm text-gray-500 mt-2">
            Please answer all questions for all students before submitting.
          </p>
        )}
      </div>
    </form>
  );
};

export default Survey;
</file>

<file path="backend/routers/groups.py">
from fastapi import APIRouter, Depends, HTTPException
from models import SessionLocal, User, Course, Group, Student, StudentGroup, StudentCourse, StudentSurvey
from sqlalchemy.orm import Session
from pydantic import BaseModel
from typing import Optional, List


router = APIRouter()


def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

@router.get("/getgroups/")
async def getGroups(courseID: int, db: Session = Depends(get_db)):
    course = db.query(Course).filter(Course.id == courseID).first()
    groups = db.query(Group).filter(Group.courseCode == course.code).all()

    return groups


@router.get("/groups/")
async def getStudentsInGroup(groupID: int, db: Session = Depends(get_db)):
    group = db.query(Group).filter(
        Group.id == groupID,
    ).first()

    if not group:
        raise HTTPException(status_code=404, detail="Group not found in this course")

    # Query StudentGroup directly with the provided groupID
    student_group_relations = db.query(StudentGroup).filter(
        StudentGroup.group_id == groupID  # Fixed filter to use the parameter
    ).all()

    # 3. Fixed list comprehension syntax
    studentIDs = [row.student_id for row in student_group_relations]

    students = db.query(Student).filter(Student.id.in_(studentIDs)).all()
    return students


#later on also need to verify that the instructor is in this course as a lecturer

@router.get("/students/")
async def getStudentInfo(studentID: int, db: Session = Depends(get_db)):

    student_row = db.query(Student).filter(Student.id == studentID).first()
    
    return student_row

@router.get("/usersgroups")
async def getGroups(studentID: int, db: Session = Depends(get_db)):
    group_ids = db.query(StudentGroup.group_id).filter(
        StudentGroup.student_id == studentID
    ).all()
    group_ids = [row[0] for row in group_ids]


    groups = db.query(Group).filter(
        Group.id.in_(group_ids)
    ).all()
    return groups;


class StudentSurveyBase(BaseModel):
    evaluator_id: int
    question_id: str
    answer: int
    evaluatee_id: int
    group_id: int
    course_id: int
    course_code: str

@router.post("/postsurvey")
async def postSurveyInstance(surveyResponse: StudentSurveyBase, db: Session = Depends(get_db)):
    db_survey = StudentSurvey(**surveyResponse.model_dump())
    db.add(db_survey)
    db.commit()
    db.refresh(db_survey)
    return db_survey
</file>

<file path="frontend/package.json">
{
  "name": "frontend",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build --no-lint",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@auth0/auth0-react": "^2.3.0",
    "@auth0/nextjs-auth0": "^4.6.0",
    "@radix-ui/react-dialog": "^1.1.14",
    "@radix-ui/react-separator": "^1.1.7",
    "@radix-ui/react-slot": "^1.2.3",
    "@radix-ui/react-tooltip": "^1.2.7",
    "@tanstack/react-table": "^8.21.3",
    "axios": "^1.9.0",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "lucide-react": "^0.511.0",
    "next": "15.3.2",
    "pg": "^8.16.0",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-dropzone": "^14.3.8",
    "tailwind-merge": "^3.3.0"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "eslint": "^9",
    "eslint-config-next": "15.3.2",
    "tailwindcss": "^4",
    "tw-animate-css": "^1.3.0",
    "typescript": "^5"
  }
}
</file>

<file path="backend/main.py">
from fastapi import FastAPI, Security, Depends, HTTPException
from utils import VerifyToken
from routers.test import router as test_router
from routers.api import router as api_router
from routers.groups import router as group_router
from sqlalchemy.orm import Session
from models import SessionLocal, User, Course
from pydantic import BaseModel
from typing import List
from fastapi.middleware.cors import CORSMiddleware
from dependencies import auth
from routers.users import router as user_router
from routers.courses import router as course_router
from routers.calculations import router as calc_router
from routers.factor import router as factor_router
#from routers.auth import router as auth_router

# Creates app instance
app = FastAPI()
#auth = VerifyToken()

app.include_router(api_router, prefix="/api")
app.include_router(group_router, prefix="/group")
app.include_router(user_router)
app.include_router(course_router)
app.include_router(calc_router, prefix='/calculate')
app.include_router(factor_router, prefix='/factor')
#app.include_router(auth_router, prefix="/auth")



origins = [
    "http://localhost:3000",  # frontend dev server (React, etc.)
    "http://127.0.0.1:3000",
    "http://localhost",       # optional
    "http://127.0.0.1",
    # "https://your-production-site.com"
]

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,              # Allows these origins
    allow_credentials=True,
    allow_methods=["*"],                # Allows all HTTP methods
    allow_headers=["*"],                # Allows all headers
)

@app.get("/")
def root():
    return {"message": "FastAPI is working!"}


def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# Pydantic model for response
class UserResponse(BaseModel):
    id: int
    name: str
    email: str

    class Config:
        orm_mode = True

class CourseResponse(BaseModel):
    code: str
    session: str
    lecturer_id: int

    class Config:
        orm_mode = True

@app.get("/users", response_model=List[UserResponse])
async def get_users(db: Session = Depends(get_db)):
    users = db.query(User).all()
    return users

@app.get("/courses/{userID}", response_model=List[CourseResponse])
async def get_courses(userID: int, db: Session = Depends(get_db)):
    lecturer_id = userID
    courses = db.query(Course).filter(Course.lecturer_id == lecturer_id).all()
    return courses


@app.get("/courses/{courseID}/{courseSession}", response_model=CourseResponse)  # Changed to single response
def get_single_course(
    courseID: str,
    courseSession: str,
    db: Session = Depends(get_db)
):
    # Use clearer variable names to avoid shadowing
    course_code = courseID
    session = add_space_manual(courseSession)
    
    # Get the course with eager loading if there are relationships
    course = (
        db.query(Course)
        .filter(
            Course.code == course_code,
            Course.session == session
        )
        .first()
    )
    
    if not course:
        raise HTTPException(
            status_code=404,
            detail=f"Course {courseID} for session {courseSession} not found"
        )
        
    return course


@app.get("/api/public")
def public():
    """No access token required to access this route"""

    result = {
        "status": "success",
        "msg": ("Hello from a public endpoint! You don't need to be "
                "authenticated to see this.")
    }
    return result



def add_space_manual(s):
    for i, char in enumerate(s):
        if char.isdigit() and i > 0 and s[i-1].isalpha():
            return s[:i] + " " + s[i:]
    return s

# @app.get("/api/private")
# def private(auth_result: str = Security(auth.verify)):
#     """A valid access token is required to access this route"""
#     result = {
#         "status": "success",
#         "msg": ("Hello from a private endpoint! You need to be "
#                 "authenticated to see this.")
#     }
#     return result


# @app.get("/api/private-scoped")
# def private_scoped(auth_result: str = Security(auth.verify, scopes=['read:messages'])):
#     """A valid access token and an appropriate scope are required to access
#     this route
#     """

#     return auth_result
</file>

<file path="backend/models.py">
from sqlalchemy import create_engine, Column, Integer, String, ForeignKey, select, Float
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker, relationship, Session
from sqlalchemy.dialects.postgresql import ARRAY

from dotenv import load_dotenv
import os

load_dotenv()

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

DATABASE_URL = os.getenv("DATABASE_URL")

engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

#helper to get find a user id base on the auth0_id
def get_user_id(auth0_id: str) -> int:
    with SessionLocal() as session:
        stmt = select(User.id).where(User.auth0_id == auth0_id)
        result = session.execute(stmt).scalar()
        return result 

#User (instructor) object
class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String)
    email = Column(String)
    auth0_id = Column(String, unique=True, index=True)
    role = Column(String, default="student")

    courses = relationship("Course", back_populates="lecturer")

#course object
class Course(Base):
    __tablename__ = "courses"
    id = Column(Integer, primary_key=True, unique=True)
    code = Column(String, index=True)
    session = Column(String)
    lecturer_id = Column(Integer, ForeignKey("users.id"))
    
    lecturer = relationship("User", back_populates="courses")
    enrollments = relationship("StudentCourse", back_populates="course")
    surveys = relationship("StudentSurvey", back_populates="course")

#student object
class Student(Base):
    __tablename__ = "students"
    id = Column(Integer, primary_key=True, index=False)
    student_id = Column(Integer, unique=True, index=False)
    email = Column(String)
    name = Column(String)
    firstname = Column(String)
    lastname = Column(String)
    utorid = Column(String, unique=True)

    groups = relationship("StudentGroup", back_populates="student")
    enrollments = relationship("StudentCourse", back_populates="student")
    
    # Fixed relationships - using StudentSurvey instead of Survey
    surveys_as_evaluator = relationship("StudentSurvey", foreign_keys="StudentSurvey.evaluator_id", back_populates="evaluator")
    surveys_as_evaluatee = relationship("StudentSurvey", foreign_keys="StudentSurvey.evaluatee_id", back_populates="evaluatee")

class Group(Base):
    __tablename__ = "groups"
    id = Column(Integer, primary_key=True, index=True)
    courseCode = Column(String)
    courseID = Column(Integer, ForeignKey("courses.id"))
    groupNumber = Column(Integer)

    students = relationship("StudentGroup", back_populates="group")
    surveys = relationship("StudentSurvey", back_populates="group")

#Student and course relation table
class StudentCourse(Base):
    __tablename__ = "enrolledin"
    id = Column(Integer, primary_key=True, index=False)
    student_id = Column(Integer, ForeignKey("students.id"))
    course_id = Column(Integer, ForeignKey("courses.id"))

    student = relationship("Student", back_populates="enrollments")
    course = relationship("Course", back_populates="enrollments")

#Student and group relation table, keeps track of which students in which groups
class StudentGroup(Base):
    __tablename__ = "student_group"
    student_id = Column(Integer, ForeignKey("students.id"), primary_key=True)
    group_id = Column(Integer, ForeignKey("groups.id"), primary_key=True)
    
    student = relationship("Student", back_populates="groups")
    group = relationship("Group", back_populates="students")


class Question(Base):
    __tablename__ = "question"
    qid = Column(String, primary_key=True)
    options = Column(ARRAY(Integer))

#Student and Survey relation table, keeps track of which students have finished which surveys for which courses
class StudentSurvey(Base):
    __tablename__ = "student_survey"
    survey_response_id = Column(Integer, primary_key=True)
    evaluator_id = Column(Integer, ForeignKey("students.id"))
    evaluatee_id = Column(Integer, ForeignKey("students.id"))
    question_id = Column(String, ForeignKey("question.qid"))
    answer = Column(Integer)
    group_id = Column(Integer, ForeignKey("groups.id"))
    course_id = Column(Integer, ForeignKey("courses.id"))
    course_code = Column(String)

    # Specify which FK to use for each relationship
    evaluator = relationship("Student", foreign_keys=[evaluator_id], back_populates="surveys_as_evaluator")
    evaluatee = relationship("Student", foreign_keys=[evaluatee_id], back_populates="surveys_as_evaluatee")
    group = relationship("Group", back_populates="surveys")
    course = relationship("Course", back_populates="surveys")


class StudentAdjustmentFactor(Base):
    __tablename__ = "student_adjustment_factors"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String)
    courseCode = Column(String)
    utorid = Column(String, ForeignKey("students.utorid"))
    courseid = Column(Integer, ForeignKey("courses.id"))
    groupNumber = Column(Integer)
    factorWithSelf = Column(Float)
    factorWithoutSelf = Column(Float)
</file>

</files>
